# Check credible intervals
# Not working until ggs works
ggplot(filter(model1tranformed,
Parameter == "b_Intercept",
Iteration > 1000),
aes(x = value))+
geom_density(fill  = "yellow",
alpha = .5)+
geom_vline(xintercept = 0,
color  = "red",
size = 1)+
scale_x_continuous(name   = "Value",
limits = c(-1, 3)) +
geom_vline(xintercept = summary(model1)$fixed[1,3],
color = "blue",
linetype = 2) +
geom_vline(xintercept = summary(model1)$fixed[1,4],
color = "blue",
linetype = 2) +
theme_light() +
labs(title = "Posterior Density of Intercept")
ggplot(filter(model1tranformed, Parameter == "b_extrav", Iteration > 1000), aes(x = value))+
geom_density(fill = "orange", alpha = .5)+
geom_vline(xintercept = 0, col = "red", size = 1)+
scale_x_continuous(name = "Value", limits = c(-.2, .6))+
geom_vline(xintercept = summary(model1)$fixed[3,3], col = "blue", linetype = 2)+
geom_vline(xintercept = summary(model1)$fixed[3,4], col = "blue", linetype = 2)+
theme_light()+
labs(title = "Posterior Density of Regression Coefficient for Extraversion")
ggplot(filter(model1tranformed, Parameter == "b_sex", Iteration > 1000), aes(x = value))+
geom_density(fill = "red", alpha = .5)+
geom_vline(xintercept = 0, col = "red", size = 1)+
scale_x_continuous(name = "Value", limits = c(-.2, 1.5))+
geom_vline(xintercept = summary(model1)$fixed[2,3], col = "blue", linetype = 2)+
geom_vline(xintercept = summary(model1)$fixed[2,4], col = "blue", linetype = 2)+
theme_light()+
labs(title = "Posterior Density of Regression Coefficient for Sex")
summary(model1)$fixed
install.packages("tidybayes")
install.packages("devtools")
install.packages("fpp3")
install.packages("lavaan")
# Load required packages
library(tidyverse)
library(brms)
library(bayesplot)
# Generate simulated data
set.seed(23)
n <- 100
temperature <- runif(n, min = 0, max = 30) # Random temperatures between 0 and 30
intercept <- 10
slope <- 0.5
noise_sd <- 3
# round to whole numbers
bike_thefts <- (intercept + slope * temperature + rnorm(n, sd = noise_sd)) %>%
round(., 0)
data <- tibble(temperature = temperature, bike_thefts = bike_thefts)
View(data)
# Some initial descriptions
summary(data)
head(data)
library(ggplot2)
ggplot(data, aes(x = temperature, y = bike_thefts)) +
geom_point() +
labs(x = "Temperature", y = "Bike thefts") +
theme_minimal()
# 2) Specify and fit the model, note the sample_prior = "only"
# this makes sure we are going to look at the prior predictive samples.
fit <- brm(bike_thefts ~ temperature, data = data,
prior = priors, family = gaussian(),
sample_prior = "only", seed = 555)
# --------------------------------------------------------------------------------------------------
# Start Bayes analysis
# 1) set the priors
priors <- prior(normal(10, 5), class = "Intercept") +
prior(normal(0, 1), class = "b")
# 2) Specify and fit the model, note the sample_prior = "only"
# this makes sure we are going to look at the prior predictive samples.
fit <- brm(bike_thefts ~ temperature, data = data,
prior = priors, family = gaussian(),
sample_prior = "only", seed = 555)
library(rstantools)
# 2) Specify and fit the model, note the sample_prior = "only"
# this makes sure we are going to look at the prior predictive samples.
fit <- brm(bike_thefts ~ temperature, data = data,
prior = priors, family = gaussian(),
sample_prior = "only", seed = 555)
pp_check(fit, type = "dens_overlay", prefix = "ppd", ndraws = 100)
# 2) Specify and fit the model, note the sample_prior = "only"
# this makes sure we are going to look at the prior predictive samples.
fit <- brm(bike_thefts ~ temperature, data = data,
prior = priors, family = gaussian(),
sample_prior = "only", seed = 555)
sqrt(0.1)
library(lavaan)
library(semTools)
# remotes::install_github("simsem/semTools/semTools")
# wd
setwd("~/GitHub/OrdinalSim")
# source necessary functions
source("DataGeneration.R")
source("Functions/MMG-SEM.R")
# Define models for future simulations
model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
S1 <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
'
S2 <- '
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
# Generate dummy data
library(lavaan)
# Simulation Design
# Which factors are going to be tested? For now:
nclus            <- c(2, 4)                 # Number of clusters
ngroups          <- c(24, 48)               # Number of groups
coeff            <- c(0.2, 0.3, 0.4)        # Initial regression parameters
N_g              <- c(50, 100, 200)         # Sample size per groups
balance          <- c("bal", "unb")         # Cluster size
NonInvThreshSize <- c(0, 0.2, 0.4)          # Threshold non-invariance size
NonInvLoadSize   <- c(0.2, 0.6)             # Loading non-invariance size
c                <- c(2, 4, 5)              # Number of categories
model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
S1 <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
'
S2 <- '
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
# Get design matrix
design <- expand.grid(nclus, ngroups, coeff, N_g, balance, NonInvThreshSize, c, NonInvLoadSize, model)
colnames(design) <- c("nclus", "ngroups", "coeff", "N_g", "balance", "NonInvThreshSize", "c", "NonInvLoadSize", "model")
rownames(design) <- NULL
rm(balance, coeff, N_g, nclus, ngroups, c, NonInvLoadSize, NonInvThreshSize)
View(design)
library(lavaan)
library(fpp3)
library(dplyr)
library(xtable)
library(ggpubr)
library(ggplot2)
library(qwraps2)
library(Cairo)
CairoWin()
# Set wd
setwd("~/GitHub/OrdinalSim/Results")
# Load empty final results matrix
load("FinalResults.Rdata")
load("design.Rdata")
# Organize the data frame
design$Condition <- as.numeric(rownames(design))
Results_final <- merge(x = design, y = Results_final, by = "Condition")
# Add names to the unnamed cols
colnames(Results_final)[which(colnames(Results_final) == "V1"):which(colnames(Results_final) == "V16")] <- c("ARI.con", "CC.con", "RMSE_B1.con", "RMSE_B2.con", "RMSE_B3.con", "RMSE_B4.con", "exo_mean.con", "cov_mean.con",
"ARI.cat", "CC.cat", "RMSE_B1.cat", "RMSE_B2.cat", "RMSE_B3.cat", "RMSE_B4.cat", "exo_mean.cat", "cov_mean.cat")
# Re-order the cols
col_order <- c("Condition", "Replication", "nclus", "ngroups", "coeff", "N_g",
"balance", "NonInvThreshSize", "NonInvLoadSize", "c",
"ARI.con", "CC.con", "RMSE_B1.con", "RMSE_B2.con", "RMSE_B3.con", "RMSE_B4.con", "exo_mean.con", "cov_mean.con",
"ARI.cat", "CC.cat", "RMSE_B1.cat", "RMSE_B2.cat", "RMSE_B3.cat", "RMSE_B4.cat", "exo_mean.cat", "cov_mean.cat")
Results_final <- Results_final[, col_order]
rm(col_order)
# Fill in the matrix with all results
ncond <- unique(Results_final$Condition) # How many conditions?
K <- length(unique(Results_final$Replication)) # How many replications?
# Indices for loading
start.idx <- which(colnames(Results_final) == "ARI.con")
end.idx   <- ncol(Results_final)
for (i in ncond) {
test <- NA
test <- try(load(paste0("ResultRow", i, ".Rdata")))
if(!c(class(test) == "try-error")){
Results_final[(K*(i-1)+1):(i*K), start.idx:end.idx] <- ResultsRow
}
}
# Remove NA results
Results_final <- Results_final %>% filter(!is.na(RMSE_B1.cat))
View(Results_final)
# Indices for loading
start.idx <- which(colnames(Results_final) == "ARI.con")
end.idx   <- ncol(Results_final)
for (i in ncond) {
test <- NA
test <- try(load(paste0("ResultRow", i, ".Rdata")))
if(!c(class(test) == "try-error")){
Results_final[(K*(i-1)+1):(i*K), start.idx:end.idx] <- ResultsRow
}
}
View(Results_final)
# Remove NA results
Results_final <- Results_final %>% filter(!is.na(RMSE_B1.cat))
View(Results_final)
design[14, ]
design[14, -ncol(design)]
library(lavaan)
library(semTools)
# remotes::install_github("simsem/semTools/semTools")
# wd
setwd("~/GitHub/OrdinalSim")
# source necessary functions
source("DataGeneration.R")
source("Functions/MMG-SEM.R")
# Define models for future simulations
model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
S1 <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
'
S2 <- '
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
# Generate dummy data
set.seed(14)
Data <- DataGeneration(model = model, nclus = 4, ngroups = 24, N_g = 100, reg_coeff = 0.2,
balance = "bal", NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5,
NonInvThreshSize = 0, NonInvGThresh = 0.5,
NonInvType = "random", randomVarX = T, c = 2)
Data$SimData <- as.data.frame(Data$SimData)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings"), std.lv = F)
# single.con <- sam(model = model, data = single.data, ordered = F, group = "group",
#                   group.equal = c("loadings", "thresholds"), std.lv = T, mm.list = list(c("F1", "F2", "F3", "F4")))
single.cat <- sem(model = model, data = single.data, ordered = T, group = "group")#, "thresholds"))
lavInspect(single.con, "est")$beta
lavInspect(single.cat, "est")$beta
lavInspect(single.con, "est")$psi
lavInspect(single.cat, "est")$psi
lavInspect(single.con, "est")$lambda
lavInspect(single.cat, "est")$lambda
lavInspect(single.con, "est")$lambda[[1]]
lavInspect(single.con, "est")$lambda
lavInspect(single.cat, "est")$lambda
Data$lambda[[1]]
# Generate dummy data
set.seed(14)
Data <- DataGeneration(model = model, nclus = 4, ngroups = 24, N_g = 100, reg_coeff = 0.2,
balance = "bal", NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5,
NonInvThreshSize = 0, NonInvGThresh = 0.5,
NonInvType = "random", randomVarX = T, c = 5)
Data$SimData <- as.data.frame(Data$SimData)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings"), std.lv = F)
# single.con <- sam(model = model, data = single.data, ordered = F, group = "group",
#                   group.equal = c("loadings", "thresholds"), std.lv = T, mm.list = list(c("F1", "F2", "F3", "F4")))
single.cat <- sem(model = model, data = single.data, ordered = T, group = "group")#, "thresholds"))
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings"), std.lv = F)
single.cat <- sem(model = model, data = single.data, ordered = T, group = "group", group.equal = c("loadings"))#, "thresholds"))
lavInspect(single.con, "est")$beta
lavInspect(single.cat, "est")$beta
lavInspect(single.con, "est")$psi
lavInspect(single.cat, "est")$psi
lavInspect(single.con, "est")$lambda
lavInspect(single.cat, "est")$lambda
Data$lambda[[1]]
# Define the non-invariances -----------------------------------------------------------------------
partable <- partable(single.cat)
partable$full <- paste0(partable$lhs, partable$op, partable$rhs)
NoninvThresh <- partable$full[which(partable$op == "|" & partable$group == 1 & partable$lhs %in% c("x2", "x3",
"m2", "m3",
"y2", "y3",
"z2", "z3"))]
# Define the non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
# Run MMG-SEM
# Continuous (Run normally as usual)
fit.con <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F,
group.equal = "loadings", group.partial = NonInv)
# Check results
round(fit.con$posteriors, 1)
# Run MMG-SEM
# Continuous (Run normally as usual)
fit.con <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2, group = "group", nclus = 4, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F,
group.equal = "loadings", group.partial = NonInv)
# (Non-)Invariance defined in the model syntax itself
# Re-scaling needs to be set to T to have covariances instead of correlations in the second step
fit.cat <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2,
group = "group", nclus = 4, seed = 1,
nstarts = 20, est_method = "local", ordered = T,
group.equal = c("loadings", "thresholds"),
group.partial = NonInv)
round(fit.cat$posteriors, 1)
# Check results
round(fit.con$posteriors, 1)
round(fit.cat$posteriors, 1)
fit.con$param$beta_ks
fit.cat$param$beta_ks
fit.con$param$lambda[[1]]
fit.cat$param$lambda[[1]]
# Re-scaling needs to be set to T to have covariances instead of correlations in the second step
fit.cat.ign <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2,
group = "group", nclus = 2, seed = 1,
nstarts = 20, est_method = "local", ordered = T,
group.equal = c("loadings", "thresholds"))
# Re-scaling needs to be set to T to have covariances instead of correlations in the second step
fit.cat.ign <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2,
group = "group", nclus = 4, seed = 1,
nstarts = 20, est_method = "local", ordered = T,
group.equal = c("loadings", "thresholds"))
set.seed(14)
Data <- DataGeneration(model = model, nclus = 4, ngroups = 24, N_g = 100, reg_coeff = 0.2,
balance = "bal", NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5,
NonInvThreshSize = 0, NonInvGThresh = 0.5,
NonInvType = "random", randomVarX = T, c = 5)
# Run MMG-SEM
# Continuous (Run normally as usual)
fit.con <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2, group = "group", nclus = 4, seed = 14,
nstarts = 20, allG = T, est_method = "local", ordered = F,
group.equal = "loadings", group.partial = NonInv)
# (Non-)Invariance defined in the model syntax itself
# Re-scaling needs to be set to T to have covariances instead of correlations in the second step
fit.cat <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2,
group = "group", nclus = 4, seed = 14,
nstarts = 20, est_method = "local", ordered = T,
group.equal = c("loadings", "thresholds"),
group.partial = NonInv)
# Re-scaling needs to be set to T to have covariances instead of correlations in the second step
fit.cat.ign <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2,
group = "group", nclus = 4, seed = 14,
nstarts = 20, est_method = "local", ordered = T,
group.equal = c("loadings", "thresholds"))
# Check results
round(fit.con$posteriors, 1)
round(fit.cat$posteriors, 1)
View(DataGeneration)
# Generate dummy data
set.seed(14)
Data <- DataGeneration(model = model, nclus = 4, ngroups = 24, N_g = 100, reg_coeff = 0.2,
balance = "bal", NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5,
NonInvThreshSize = 0, NonInvGThresh = 0.5,
NonInvType = "random", randomVarX = T, c = 2)
# With modelsel code (for continouos trials)
# Data <- DataGeneration(model = model, nclus = 2, ngroups = 6, N_g = 50, reg_coeff = 0.4,
#                        balance = "bal", sd = 0)
Data$SimData <- as.data.frame(Data$SimData)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
single.con <- sem(model = model, data = single.data, ordered = F, group = "group")
single.cat <- sem(model = model, data = single.data, ordered = T, group = "group")
lavInspect(single.con, "est")$beta
lavInspect(single.cat, "est")$beta
lavInspect(single.con, "est")$psi
lavInspect(single.cat, "est")$psi
lavInspect(single.con, "est")$lambda
lavInspect(single.cat, "est")$lambda
Data$lambda[[1]]
# summary(single.con)
# summary(single.cat)
# Define the non-invariances -----------------------------------------------------------------------
partable <- partable(single.cat)
partable$full <- paste0(partable$lhs, partable$op, partable$rhs)
NoninvThresh <- partable$full[which(partable$op == "|" & partable$group == 1 & partable$lhs %in% c("x2", "x3",
"m2", "m3",
"y2", "y3",
"z2", "z3"))]
# Define the non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
# Run MMG-SEM
# Continuous (Run normally as usual)
fit.con <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2, group = "group", nclus = 4, seed = 14,
nstarts = 20, allG = T, est_method = "local", ordered = F,
group.equal = "loadings", group.partial = NonInv)
# (Non-)Invariance defined in the model syntax itself
# Re-scaling needs to be set to T to have covariances instead of correlations in the second step
fit.cat <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2,
group = "group", nclus = 4, seed = 14,
nstarts = 20, est_method = "local", ordered = T,
group.equal = c("loadings", "thresholds"),
group.partial = NonInv)
# Re-scaling needs to be set to T to have covariances instead of correlations in the second step
fit.cat.ign <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2,
group = "group", nclus = 4, seed = 14,
nstarts = 20, est_method = "local", ordered = T,
group.equal = c("loadings", "thresholds"))
# Check results
round(fit.con$posteriors, 1)
round(fit.cat$posteriors, 1)
fit.con$param$beta_ks
fit.cat$param$beta_ks
fit.cat.ign$param$beta_ks
con_rmse <- c()
for(g in 1:6){
con_rmse[g] <- sqrt(mean((fit.con$param$lambda[[g]][which(fit.con$param$lambda[[g]] != 0 & fit.con$param$lambda[[g]] != 1)] -
Data$lambda[[g]][which(Data$lambda[[g]] != 0 & Data$lambda[[g]] != 1)])^2))
}
cat_rmse <- c()
for(g in 1:6){
cat_rmse[g] <- sqrt(mean((fit.cat$param$lambda[[g]][which(fit.cat$param$lambda[[g]] != 0 & round(fit.cat$param$lambda[[g]], 3) != 1)] -
Data$lambda[[g]][which(Data$lambda[[g]] != 0 & Data$lambda[[g]] != 1)])^2))
}
cat.ign_rmse <- c()
for(g in 1:6){
cat.ign_rmse[g] <- sqrt(mean((fit.cat.ign$param$lambda[[g]][which(fit.cat.ign$param$lambda[[g]] != 0 & round(fit.cat.ign$param$lambda[[g]], 3) != 1)] -
Data$lambda[[g]][which(Data$lambda[[g]] != 0 & Data$lambda[[g]] != 1)])^2))
}
mean(con_rmse)
mean(cat_rmse)
mean(cat.ign_rmse)
con_rmse <- c()
for(g in 1:24){
con_rmse[g] <- sqrt(mean((fit.con$param$lambda[[g]][which(fit.con$param$lambda[[g]] != 0 & fit.con$param$lambda[[g]] != 1)] -
Data$lambda[[g]][which(Data$lambda[[g]] != 0 & Data$lambda[[g]] != 1)])^2))
}
cat_rmse <- c()
for(g in 1:24){
cat_rmse[g] <- sqrt(mean((fit.cat$param$lambda[[g]][which(fit.cat$param$lambda[[g]] != 0 & round(fit.cat$param$lambda[[g]], 3) != 1)] -
Data$lambda[[g]][which(Data$lambda[[g]] != 0 & Data$lambda[[g]] != 1)])^2))
}
cat.ign_rmse <- c()
for(g in 1:24){
cat.ign_rmse[g] <- sqrt(mean((fit.cat.ign$param$lambda[[g]][which(fit.cat.ign$param$lambda[[g]] != 0 & round(fit.cat.ign$param$lambda[[g]], 3) != 1)] -
Data$lambda[[g]][which(Data$lambda[[g]] != 0 & Data$lambda[[g]] != 1)])^2))
}
mean(con_rmse)
mean(cat_rmse)
mean(cat.ign_rmse)
# (Non-)Invariance defined in the model syntax itself
# Re-scaling needs to be set to T to have covariances instead of correlations in the second step
fit.cat <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2,
group = "group", nclus = 4, seed = 14,
nstarts = 20, est_method = "local", ordered = T,
group.equal = c("loadings", "thresholds"),
group.partial = NonInv, estimator = "ULS")
# Re-scaling needs to be set to T to have covariances instead of correlations in the second step
fit.cat.ign <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2,
group = "group", nclus = 4, seed = 14,
nstarts = 20, est_method = "local", ordered = T,
group.equal = c("loadings", "thresholds"), estimator = "ULS")
con_rmse <- c()
for(g in 1:24){
con_rmse[g] <- sqrt(mean((fit.con$param$lambda[[g]][which(fit.con$param$lambda[[g]] != 0 & fit.con$param$lambda[[g]] != 1)] -
Data$lambda[[g]][which(Data$lambda[[g]] != 0 & Data$lambda[[g]] != 1)])^2))
}
cat_rmse <- c()
for(g in 1:24){
cat_rmse[g] <- sqrt(mean((fit.cat$param$lambda[[g]][which(fit.cat$param$lambda[[g]] != 0 & round(fit.cat$param$lambda[[g]], 3) != 1)] -
Data$lambda[[g]][which(Data$lambda[[g]] != 0 & Data$lambda[[g]] != 1)])^2))
}
cat.ign_rmse <- c()
for(g in 1:24){
cat.ign_rmse[g] <- sqrt(mean((fit.cat.ign$param$lambda[[g]][which(fit.cat.ign$param$lambda[[g]] != 0 & round(fit.cat.ign$param$lambda[[g]], 3) != 1)] -
Data$lambda[[g]][which(Data$lambda[[g]] != 0 & Data$lambda[[g]] != 1)])^2))
}
mean(con_rmse)
mean(cat_rmse)
mean(cat.ign_rmse)
View(MMGSEM)
source("~/GitHub/OrdinalSim/Functions/MMG-SEM.R", echo=TRUE)
mean(con_rmse)
mean(cat_rmse)
mean(cat.ign_rmse)
