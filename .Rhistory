# Fix values of loadings and error variances
# Loadings
par_table$ustart[1] <- fixed_values["ld_f1"]
par_table$ustart[2] <- fixed_values["ld_f2"]
par_table$ustart[3] <- fixed_values["ld_f3"]
# Error variances
par_table$ustart[6] <- fixed_values["SE_F1"]
par_table$ustart[7] <- fixed_values["SE_F2"]
par_table$ustart[8] <- fixed_values["SE_F3"]
str.final <- cfa(model = par_table, data = fs, std.lv = T, se = "none", control=list(iter.max=50))
summary(str.final)
library(lavaan)
library(mirt)
library(dplyr)
# Data Generation
# set.seed(5)
# Define relevant variables
N   <- 1000
thresh1 <- c(-1.2, 0.2, 1.2)
thresh2 <- c(-1.2, 0.2, 1.2)
thresh3 <- c(-1.2, 0.2, 1.2)
thresh4 <- c(-1.2, 0.2, 1.2)
thresh5 <- c(-1.2, 0.2, 1.2)
thresh6 <- c(-1.2, 0.2, 1.2)
thresh7 <- c(-1.2, 0.2, 1.2)
thresh8 <- c(-1.2, 0.2, 1.2)
thresh9 <- c(-1.2, 0.2, 1.2)
# thresh1 <- c(-2, 0, 2)
# thresh2 <- c(-1, 0, 1)
# thresh3 <- c(-1.2, 0.2, 1.2)
# thresh4 <- c(-2.3, -0.5, 1)
# thresh5 <- c(-1.2, 0.5, 1.7)
# thresh6 <- c(-1.3, 0.7, 2.3)
# thresh7 <- c(-2.4, -0.3, 0.7)
# thresh8 <- c(-1.2, 0.6, 1.8)
# thresh9 <- c(-1.4, 0.7, 1.9)
# Generate data
# MM
load <- 0.7
sload <- sqrt(load)
lambda <- matrix(c(1,     0,     0,
sload, 0,     0,
sload, 0,     0,
0,     1,     0,
0,     sload, 0,
0,     sload, 0,
0,     0,     1,
0,     0,     sload,
0,     0,     sload), byrow = T, ncol = 3)
theta <- diag(9)
theta[theta != 0] <- rnorm(9, mean = (1 - load), sd = 0.1)
# SM
beta <- matrix(c(0, 0.3, 0.3,
0, 0,   0  ,
0, 0,   0  ), byrow = T, ncol = 3)
psi  <- matrix(c(1, 0,   0,
0, 1,   0.5,
0, 0.5, 1), byrow = T, ncol = 3)
I <- diag(3)
phi <- solve(I - beta) %*% psi %*% solve(t(I - beta))
Data <- as.data.frame(mvrnorm(n = N, mu = rep(0, 9), Sigma = sigma, empirical = T)) # These are factor scores
# Factor scores
library(MASS)
Data <- as.data.frame(mvrnorm(n = N, mu = rep(0, 9), Sigma = phi, empirical = T)) # These are factor scores
phi
Data <- as.data.frame(mvrnorm(n = N, mu = rep(0, 3), Sigma = phi, empirical = T)) # These are factor scores
# Check lavaan cont
model <- "f1 =~ x1 + x2 + x3
f2 =~ x4 + x5 + x6
f3 =~ x7 + x8 + x9
f1 ~ f2 + f3"
View(Data)
# Make categorical
Data <- matrix(data = NA, nrow = 1000, ncol = 9)
phi <- solve(I - beta) %*% psi %*% solve(t(I - beta))
facsc <- as.data.frame(mvrnorm(n = N, mu = rep(0, 3), Sigma = phi, empirical = T)) # These are factor scores
# Make categorical
Data <- matrix(data = NA, nrow = 1000, ncol = 9)
Data[, 1] <- as.numeric(cut(facsc[, 1], breaks = c(-Inf, thresh1, Inf)))
Data[, 2] <- as.numeric(cut(facsc[, 1], breaks = c(-Inf, thresh2, Inf)))
Data[, 3] <- as.numeric(cut(facsc[, 1], breaks = c(-Inf, thresh3, Inf)))
Data[, 4] <- as.numeric(cut(facsc[, 2], breaks = c(-Inf, thresh4, Inf)))
Data[, 5] <- as.numeric(cut(facsc[, 2], breaks = c(-Inf, thresh5, Inf)))
Data[, 6] <- as.numeric(cut(facsc[, 2], breaks = c(-Inf, thresh6, Inf)))
Data[, 7] <- as.numeric(cut(facsc[, 3], breaks = c(-Inf, thresh7, Inf)))
Data[, 8] <- as.numeric(cut(facsc[, 3], breaks = c(-Inf, thresh8, Inf)))
Data[, 9] <- as.numeric(cut(facsc[, 3], breaks = c(-Inf, thresh9, Inf)))
# Check lavaan vs mirt
model.sem.cat  <- sem(model = model, data = Data, ordered = T, std.lv = F)
colnames(Data) <- paste0(rep("x", 9), 1:9)
# Check lavaan vs mirt
model.sem.cat  <- sem(model = model, data = Data, ordered = T, std.lv = F)
# summary(model.sem.cat, rsquare = T)
lavInspect(model.sem.cat, what = "est")$beta
model.mirt <- mirt(Data,
model = "F1 = 1-3,
F2 = 4-6,
F3 = 7-9",
itemtype = "graded")
fs <- fscores(model.mirt) #, full.scores.SE = T)
lm(F1 ~ F2 + F3, data = as.data.frame(fs))
lm(f1 ~ f2 + f3, data = as.data.frame(predict(model.sem.cat)))
# Lavaan continuous
model.sem.con  <- sem(model = model, data = Data, ordered = F, std.lv = F)
View(Data)
library(lavaan)
library(mirt)
library(dplyr)
# Data Generation
# set.seed(5)
# Define relevant variables
N   <- 1000
# thresh1 <- c(-1.2, 0.2, 1.2)
# thresh2 <- c(-1.2, 0.2, 1.2)
# thresh3 <- c(-1.2, 0.2, 1.2)
# thresh4 <- c(-1.2, 0.2, 1.2)
# thresh5 <- c(-1.2, 0.2, 1.2)
# thresh6 <- c(-1.2, 0.2, 1.2)
# thresh7 <- c(-1.2, 0.2, 1.2)
# thresh8 <- c(-1.2, 0.2, 1.2)
# thresh9 <- c(-1.2, 0.2, 1.2)
thresh1 <- c(-2, 0, 2)
thresh2 <- c(-1, 0, 1)
thresh3 <- c(-1.2, 0.2, 1.2)
thresh4 <- c(-2.3, -0.5, 1)
thresh5 <- c(-1.2, 0.5, 1.7)
thresh6 <- c(-1.3, 0.7, 2.3)
thresh7 <- c(-2.4, -0.3, 0.7)
thresh8 <- c(-1.2, 0.6, 1.8)
thresh9 <- c(-1.4, 0.7, 1.9)
# Generate data
# MM
load <- 0.7
sload <- sqrt(load)
lambda <- matrix(c(1,     0,     0,
sload, 0,     0,
sload, 0,     0,
0,     1,     0,
0,     sload, 0,
0,     sload, 0,
0,     0,     1,
0,     0,     sload,
0,     0,     sload), byrow = T, ncol = 3)
theta <- diag(9)
theta[theta != 0] <- rnorm(9, mean = (1 - load), sd = 0.1)
# SM
beta <- matrix(c(0, 0.3, 0.3,
0, 0,   0  ,
0, 0,   0  ), byrow = T, ncol = 3)
psi  <- matrix(c(1, 0,   0,
0, 1,   0.5,
0, 0.5, 1), byrow = T, ncol = 3)
I <- diag(3)
# Factor scores
library(MASS)
phi <- solve(I - beta) %*% psi %*% solve(t(I - beta))
facsc <- as.data.frame(mvrnorm(n = N, mu = rep(0, 3), Sigma = phi, empirical = T)) # These are factor scores
# Observed data
# library(MASS)
# sigma <- lambda %*% solve(I - beta) %*% psi %*% solve(t(I - beta)) %*% t(lambda) + theta
# Data <- as.data.frame(mvrnorm(n = N, mu = rep(0, 9), Sigma = sigma, empirical = T))
# colnames(Data) <- paste0(rep("x", 9), 1:9)
# Check lavaan cont
model <- "f1 =~ x1 + x2 + x3
f2 =~ x4 + x5 + x6
f3 =~ x7 + x8 + x9
f1 ~ f2 + f3"
# model.sem  <- sem(model = model, data = Data, ordered = F, std.lv = F)
# summary(model.sem, rsquare = T)
# cor(Data)
# Make categorical
Data <- matrix(data = NA, nrow = 1000, ncol = 9)
Data[, 1] <- as.numeric(cut(facsc[, 1], breaks = c(-Inf, thresh1, Inf)))
Data[, 2] <- as.numeric(cut(facsc[, 1], breaks = c(-Inf, thresh2, Inf)))
Data[, 3] <- as.numeric(cut(facsc[, 1], breaks = c(-Inf, thresh3, Inf)))
Data[, 4] <- as.numeric(cut(facsc[, 2], breaks = c(-Inf, thresh4, Inf)))
Data[, 5] <- as.numeric(cut(facsc[, 2], breaks = c(-Inf, thresh5, Inf)))
Data[, 6] <- as.numeric(cut(facsc[, 2], breaks = c(-Inf, thresh6, Inf)))
Data[, 7] <- as.numeric(cut(facsc[, 3], breaks = c(-Inf, thresh7, Inf)))
Data[, 8] <- as.numeric(cut(facsc[, 3], breaks = c(-Inf, thresh8, Inf)))
Data[, 9] <- as.numeric(cut(facsc[, 3], breaks = c(-Inf, thresh9, Inf)))
colnames(Data) <- paste0(rep("x", 9), 1:9)
# Data[, 1] <- as.numeric(cut(Data[, 1], breaks = c(-Inf, thresh1, Inf)))
# Data[, 2] <- as.numeric(cut(Data[, 2], breaks = c(-Inf, thresh2, Inf)))
# Data[, 3] <- as.numeric(cut(Data[, 3], breaks = c(-Inf, thresh3, Inf)))
# Data[, 4] <- as.numeric(cut(Data[, 4], breaks = c(-Inf, thresh4, Inf)))
# Data[, 5] <- as.numeric(cut(Data[, 5], breaks = c(-Inf, thresh5, Inf)))
# Data[, 6] <- as.numeric(cut(Data[, 6], breaks = c(-Inf, thresh6, Inf)))
# Data[, 7] <- as.numeric(cut(Data[, 7], breaks = c(-Inf, thresh7, Inf)))
# Data[, 8] <- as.numeric(cut(Data[, 8], breaks = c(-Inf, thresh8, Inf)))
# Data[, 9] <- as.numeric(cut(Data[, 9], breaks = c(-Inf, thresh9, Inf)))
# cor(Data)
# lavCor(Data, ordered = T)
# Check lavaan vs mirt
model.sem.cat  <- sem(model = model, data = Data, ordered = T, std.lv = F)
# summary(model.sem.cat, rsquare = T)
lavInspect(model.sem.cat, what = "est")$beta
model.mirt <- mirt(Data,
model = "F1 = 1-3,
F2 = 4-6,
F3 = 7-9",
itemtype = "graded")
fs <- fscores(model.mirt) #, full.scores.SE = T)
lm(F1 ~ F2 + F3, data = as.data.frame(fs))
lm(f1 ~ f2 + f3, data = as.data.frame(predict(model.sem.cat)))
# Lavaan continuous
model.sem.con  <- sem(model = model, data = Data, ordered = F, std.lv = F)
# summary(model.sem.con)
lavInspect(model.sem.con, what = "est")$beta
quantile(rnorm(100, 1), .5)
quantile(rnorm(100, 1), c(0, .25, .5, .75, 1)
)
quantile(rnorm(1000, 1), c(0, .25, .5, .75, 1))
quantile(rnorm(1000, 0, 1), c(0, .25, .5, .75, 1))
1/6
1/5
1/4
quantile(rnorm(1000, 0, 1), c(.2, .4, .6, .8))
quantile(rnorm(1000, 0, 1), c(.5))
quantile(rnorm(1000, 0, 1), c(.3))
quantile(rnorm(1000, 0, 1), c(.2))
quantile(rnorm(1000, 0, 1), c(.6))
quantile(rnorm(1000, 0, 1), c(.9))
quantile(rnorm(1000, 0, 1), c(.8))
library(lavaan)
# Set the working directory
setwd("~/GitHub/OrdinalSim/Functions")
# Source the relevant functions
source("MMG-SEM.R")
source("E_Step.R")
source("ModelSelection.R")
setwd("~/GitHub/OrdinalSim/")
source("DataGeneration.R")
# Simulation Design
# Which factors are going to be tested? For now:
nclus   <- c(2, 4)         # Number of clusters
ngroups <- c(24, 48)       # Number of groups
coeff   <- c(0.3, 0.4)     # Initial regression parameters
N_g     <- c(50, 100, 200) # Sample size per groups
balance <- c("bal", "unb") # Cluster size
sd      <- c(0, 0.05, 0.1) # Differences within a cluster (in betas)
library(lavaan)
# wd
setwd("~/GitHub/OrdinalSim")
# source necessary functions
source("DataGeneration.R")
source("Functions/MMG-SEM.R")
# Define models for future simulations
model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
S1 <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
'
S2 <- '
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
# Generate dummy data
set.seed(10)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 12, N_g = 200, reg_coeff = 0.3,
balance = "unb", NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5, threshold = "unequal",
NonInvType = "fixed", randomVarX = T, c = 3)
Data$SimData <- as.data.frame(Data$SimData)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
# Generate dummy data
set.seed(12)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 12, N_g = 200, reg_coeff = 0.3,
balance = "unb", NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5, threshold = "unequal",
NonInvType = "fixed", randomVarX = T, c = 3)
Data$SimData <- as.data.frame(Data$SimData)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings", "thresholds"))
single.cat <- sem(model = model, data = single.data, ordered = T, group = "group", group.equal = c("loadings", "thresholds"))
lavInspect(single.con, "est")$beta
lavInspect(single.cat, "est")$beta
partable <- partable(single.cat)
partable$full <- paste0(partable$lhs, partable$op, partable$rhs)
NoninvThresh <- partable$full[which(partable$op == "|" & partable$group == 1)]# & partable$lhs %in% c("x2", "m2", "y2", "z2"))]
# Define the non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
NoninvThresh
# Run MMG-SEM
fit.con <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F, constraints = c("loadings", "thresholds"))
fit.cat <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = T, NonInv = NonInv, constraints = c("loadings", "thresholds"))
View(DataGeneration)
NonInv
source("~/GitHub/OrdinalSim/DataGeneration.R", echo=TRUE)
# Generate dummy data
set.seed(12)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 12, N_g = 200, reg_coeff = 0.3,
balance = "unb", NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5, threshold = "unequal",
NonInvType = "fixed", randomVarX = T, c = 3)
Data$SimData <- as.data.frame(Data$SimData)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings", "thresholds"))
single.cat <- sem(model = model, data = single.data, ordered = T, group = "group", group.equal = c("loadings", "thresholds"))
lavInspect(single.con, "est")$beta
lavInspect(single.cat, "est")$beta
partable <- partable(single.cat)
partable$full <- paste0(partable$lhs, partable$op, partable$rhs)
NoninvThresh <- partable$full[which(partable$op == "|" & partable$group == 1)]# & partable$lhs %in% c("x2", "m2", "y2", "z2"))]
# Define the non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
# Run MMG-SEM
fit.con <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F, constraints = c("loadings", "thresholds"))
fit.cat <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = T, NonInv = NonInv, constraints = c("loadings", "thresholds"))
round(fit.con$posteriors, 2)
round(fit.cat$posteriors, 2)
fit.con$param$beta_ks
fit.cat$param$beta_ks
lapply(lavInspect(fit.cat$MM, "est"), "[[", "tau")
set.seed(12)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 12, N_g = 200, reg_coeff = 0.3,
balance = "unb", NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5, threshold = "unequal",
NonInvType = "fixed", randomVarX = T, c = 2)
Data$SimData <- as.data.frame(Data$SimData)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings", "thresholds"))
single.cat <- sem(model = model, data = single.data, ordered = T, group = "group", group.equal = c("loadings", "thresholds"))
lavInspect(single.con, "est")$beta
lavInspect(single.cat, "est")$beta
partable <- partable(single.cat)
partable$full <- paste0(partable$lhs, partable$op, partable$rhs)
NoninvThresh <- partable$full[which(partable$op == "|" & partable$group == 1)]# & partable$lhs %in% c("x2", "m2", "y2", "z2"))]
# Define the non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
# Run MMG-SEM
fit.con <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F, constraints = c("loadings", "thresholds"))
fit.cat <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = T, NonInv = NonInv, constraints = c("loadings", "thresholds"))
round(fit.con$posteriors, 2)
round(fit.cat$posteriors, 2)
fit.con$param$beta_ks
fit.cat$param$beta_ks
set.seed(12)
Data <- DataGeneration(model = model, nclus = 4, ngroups = 12, N_g = 200, reg_coeff = 0.3,
balance = "unb", NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5, threshold = "unequal",
NonInvType = "fixed", randomVarX = T, c = 2)
Data$SimData <- as.data.frame(Data$SimData)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings", "thresholds"))
single.cat <- sem(model = model, data = single.data, ordered = T, group = "group", group.equal = c("loadings", "thresholds"))
lavInspect(single.con, "est")$beta
lavInspect(single.cat, "est")$beta
partable <- partable(single.cat)
partable$full <- paste0(partable$lhs, partable$op, partable$rhs)
NoninvThresh <- partable$full[which(partable$op == "|" & partable$group == 1)]# & partable$lhs %in% c("x2", "m2", "y2", "z2"))]
# Define the non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
# Run MMG-SEM
fit.con <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 4, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F, constraints = c("loadings", "thresholds"))
fit.cat <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 4, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = T, NonInv = NonInv, constraints = c("loadings", "thresholds"))
round(fit.con$posteriors, 2)
round(fit.cat$posteriors, 2)
fit.con$param$beta_ks
fit.cat$param$beta_ks
lavInspect(single.con, "est")$beta
lavInspect(single.cat, "est")$beta
# Generate dummy data
set.seed(12)
Data <- DataGeneration(model = model, nclus = 4, ngroups = 12, N_g = 100, reg_coeff = 0.3,
balance = "unb", NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5, threshold = "unequal",
NonInvType = "fixed", randomVarX = T, c = 2)
Data$SimData <- as.data.frame(Data$SimData)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings", "thresholds"))
single.cat <- sem(model = model, data = single.data, ordered = T, group = "group", group.equal = c("loadings", "thresholds"))
lavInspect(single.con, "est")$beta
lavInspect(single.cat, "est")$beta
partable <- partable(single.cat)
partable$full <- paste0(partable$lhs, partable$op, partable$rhs)
NoninvThresh <- partable$full[which(partable$op == "|" & partable$group == 1)]# & partable$lhs %in% c("x2", "m2", "y2", "z2"))]
# Define the non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
# Run MMG-SEM
fit.con <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 4, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F, constraints = c("loadings", "thresholds"))
fit.cat <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 4, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = T, NonInv = NonInv, constraints = c("loadings", "thresholds"))
NoninvThresh <- partable$full[which(partable$op == "|" & partable$group == 1) & partable$lhs %in% c("x2", "m2", "y2", "z2"))]
# Define the non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
# Run MMG-SEM
fit.con <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 4, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F, constraints = c("loadings", "thresholds"))
fit.cat <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 4, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = T, NonInv = NonInv, constraints = c("loadings", "thresholds"))
set.seed(12)
Data <- DataGeneration(model = model, nclus = 4, ngroups = 12, N_g = 100, reg_coeff = 0.3,
balance = "unb", NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5, threshold = "unequal",
NonInvType = "fixed", randomVarX = T, c = 2)
Data$SimData <- as.data.frame(Data$SimData)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings", "thresholds"))
single.cat <- sem(model = model, data = single.data, ordered = T, group = "group", group.equal = c("loadings", "thresholds"))
lavInspect(single.con, "est")$beta
lavInspect(single.cat, "est")$beta
partable <- partable(single.cat)
partable$full <- paste0(partable$lhs, partable$op, partable$rhs)
NoninvThresh <- partable$full[which(partable$op == "|" & partable$group == 1 & partable$lhs %in% c("x2", "m2", "y2", "z2"))]
# Define the non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
# Run MMG-SEM
fit.con <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 4, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F, constraints = c("loadings", "thresholds"))
fit.cat <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 4, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = T, NonInv = NonInv, constraints = c("loadings", "thresholds"))
round(fit.con$posteriors, 2)
round(fit.cat$posteriors, 2)
fit.con$param$beta_ks
fit.cat$param$beta_ks
set.seed(12)
Data <- DataGeneration(model = model, nclus = 4, ngroups = 12, N_g = 100, reg_coeff = 0.3,
balance = "unb", NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.25, threshold = "unequal",
NonInvType = "fixed", randomVarX = T, c = 2)
Data$SimData <- as.data.frame(Data$SimData)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings", "thresholds"))
single.cat <- sem(model = model, data = single.data, ordered = T, group = "group", group.equal = c("loadings", "thresholds"))
lavInspect(single.con, "est")$beta
lavInspect(single.cat, "est")$beta
partable <- partable(single.cat)
partable$full <- paste0(partable$lhs, partable$op, partable$rhs)
NoninvThresh <- partable$full[which(partable$op == "|" & partable$group == 1 & partable$lhs %in% c("x2", "m2", "y2", "z2"))]
# Define the non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
# Run MMG-SEM
fit.con <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 4, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F, constraints = c("loadings", "thresholds"))
fit.cat <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 4, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = T, NonInv = NonInv, constraints = c("loadings", "thresholds"))
round(fit.con$posteriors, 2)
round(fit.cat$posteriors, 2)
fit.con$param$beta_ks
fit.cat$param$beta_ks
fit.con$param$lambda
fit.cat$param$lambda
lapply(lavInspect(fit.cat$MM, "est"), "[[", "tau")
