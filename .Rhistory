ggplot(filter(model1tranformed, Parameter == "b_extrav", Iteration > 1000), aes(x = value))+
geom_density(fill = "orange", alpha = .5)+
geom_vline(xintercept = 0, col = "red", size = 1)+
scale_x_continuous(name = "Value", limits = c(-.2, .6))+
geom_vline(xintercept = summary(model1)$fixed[3,3], col = "blue", linetype = 2)+
geom_vline(xintercept = summary(model1)$fixed[3,4], col = "blue", linetype = 2)+
theme_light()+
labs(title = "Posterior Density of Regression Coefficient for Extraversion")
ggplot(filter(model1tranformed, Parameter == "b_sex", Iteration > 1000), aes(x = value))+
geom_density(fill = "red", alpha = .5)+
geom_vline(xintercept = 0, col = "red", size = 1)+
scale_x_continuous(name = "Value", limits = c(-.2, 1.5))+
geom_vline(xintercept = summary(model1)$fixed[2,3], col = "blue", linetype = 2)+
geom_vline(xintercept = summary(model1)$fixed[2,4], col = "blue", linetype = 2)+
theme_light()+
labs(title = "Posterior Density of Regression Coefficient for Sex")
summary(model1)$fixed
install.packages("tidybayes")
install.packages("devtools")
install.packages("fpp3")
install.packages("lavaan")
# Load required packages
library(tidyverse)
library(brms)
library(bayesplot)
# Generate simulated data
set.seed(23)
n <- 100
temperature <- runif(n, min = 0, max = 30) # Random temperatures between 0 and 30
intercept <- 10
slope <- 0.5
noise_sd <- 3
# round to whole numbers
bike_thefts <- (intercept + slope * temperature + rnorm(n, sd = noise_sd)) %>%
round(., 0)
data <- tibble(temperature = temperature, bike_thefts = bike_thefts)
View(data)
# Some initial descriptions
summary(data)
head(data)
library(ggplot2)
ggplot(data, aes(x = temperature, y = bike_thefts)) +
geom_point() +
labs(x = "Temperature", y = "Bike thefts") +
theme_minimal()
# 2) Specify and fit the model, note the sample_prior = "only"
# this makes sure we are going to look at the prior predictive samples.
fit <- brm(bike_thefts ~ temperature, data = data,
prior = priors, family = gaussian(),
sample_prior = "only", seed = 555)
# --------------------------------------------------------------------------------------------------
# Start Bayes analysis
# 1) set the priors
priors <- prior(normal(10, 5), class = "Intercept") +
prior(normal(0, 1), class = "b")
# 2) Specify and fit the model, note the sample_prior = "only"
# this makes sure we are going to look at the prior predictive samples.
fit <- brm(bike_thefts ~ temperature, data = data,
prior = priors, family = gaussian(),
sample_prior = "only", seed = 555)
library(rstantools)
# 2) Specify and fit the model, note the sample_prior = "only"
# this makes sure we are going to look at the prior predictive samples.
fit <- brm(bike_thefts ~ temperature, data = data,
prior = priors, family = gaussian(),
sample_prior = "only", seed = 555)
pp_check(fit, type = "dens_overlay", prefix = "ppd", ndraws = 100)
# 2) Specify and fit the model, note the sample_prior = "only"
# this makes sure we are going to look at the prior predictive samples.
fit <- brm(bike_thefts ~ temperature, data = data,
prior = priors, family = gaussian(),
sample_prior = "only", seed = 555)
library(lavaan)
source("~/GitHub/OrdinalSim/DataGeneration.R", echo=TRUE)
# wd
setwd("~/GitHub/OrdinalSim")
source("Functions/MMG-SEM.R")
# Define models for future simulations
model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
S1 <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
'
S2 <- '
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
# Generate dummy data
set.seed(12)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 6, N_g = 200, reg_coeff = 0.4,
balance = "bal", NonInvSize = 0.2, NonInvItems = 2,
threshold = "unequal", NonInvThreshSize = 0,
NonInvType = "random", randomVarX = T, c = 2)
Data$SimData <- as.data.frame(Data$SimData)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings", "thresholds"))
single.cat <- sem(model = model, data = single.data, ordered = T, group = "group", group.equal = c("loadings", "thresholds"))
lavInspect(single.con, "est")$beta
lavInspect(single.cat, "est")$beta
lavInspect(single.con, "est")$psi
lavInspect(single.cat, "est")$psi
partable <- partable(single.cat)
partable$full <- paste0(partable$lhs, partable$op, partable$rhs)
NoninvThresh <- partable$full[which(partable$op == "|" & partable$group == 1 & partable$lhs %in% c("x2", #, "x3",
"m2", #, "m3",
"y2", #, "y3",
"z2"))] #, "z3"))]
# Define the non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
# Run MMG-SEM
fit.con <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F, constraints = c("loadings", "thresholds"))
fit.cat <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = T, NonInv = NonInv, constraints = c("loadings"))#, "thresholds"))
fit.cat2 <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = T, NonInv = NonInv, constraints = c("loadings", "thresholds"))
round(fit.con$posteriors, 2)
round(fit.cat$posteriors, 2)
round(fit.cat2$posteriors, 2)
fit.con$param$beta_ks
fit.cat$param$beta_ks
fit.cat2$param$lambda
fit.cat2$param$beta_ks
Data$NonInv$thresh
Data$thresh
lapply(lavInspect(fit.cat$MM, "est"), "[[", "tau")
fit.cat$MM
fit.cat2$MM
View(partable(fit.cat2$MM))
# Try only the measurement model
con <- cfa(model = S1, data = Data$SimData, ordered = F, group = "group", group.equal = "loadings")
cat <- cfa(model = S1, data = Data$SimData, ordered = T, group = "group", group.equal = "loadings")
cat2 <- cfa(model = S1, data = Data$SimData, ordered = T, group = "group", group.equal = c("loadings", "thresholds"))
lapply(lavInspect(cat2, "est"), "[[", "psi")
lapply(lavInspect(cat, "est"), "[[", "psi")
lapply(lavInspect(fit.cat$MM, "est"), "[[", "tau")
?semTools::measEq.syntax
install.packages("semtoold")
install.packages("semtools")
install.packages("semTools")
?semTools::measEq.syntax
cat
cat2
View(partable(cats))
View(partable(cat))
View(partable(cat2))
summary(cat2)
cat2 <- cfa(model = S1, data = Data$SimData, ordered = T, group = "group", group.equal = c("thresholds"))
lapply(lavInspect(cat2, "est"), "[[", "psi")
View(Data$SimData)
# Try Wu and Estabrook approach
Thr.Mod <- measEq.syntax(configural.model = S1,
dat = Data$SimData,
parameterization = "delta",
ordered = colnames(Data$SimData[,-c(dim(Data$SimData)[2])]),
ID.fac = "marker",
ID.cat = "Wu",
group = "group",
group.equal = c("thresholds"))
library(semTools)
# Try Wu and Estabrook approach
Thr.Mod <- measEq.syntax(configural.model = S1,
dat = Data$SimData,
parameterization = "delta",
ordered = colnames(Data$SimData[,-c(dim(Data$SimData)[2])]),
ID.fac = "marker",
ID.cat = "Wu",
group = "group",
group.equal = c("thresholds"))
fit.thr <- cfa(as.character(Thr.Mod),
data = Data$SimData,
group = "group",
ordered = T)
summary(fit.thr)
as.character(Thr.Mod)
View(MMGSEM)
source("~/GitHub/OrdinalSim/Functions/MMG-SEM.R", echo=TRUE)
# Wu asks for std.lv = T. Never been tested in MMG-sEM
# Try it
fit.con <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F, std.lv = T,
constraints = c("loadings", "thresholds"))
round(fit.con$posteriors, 1)
fit.con$param$beta_ks
fit.con$param$psi_gks
fit.con$param$psi_gks[[1,1]]
source("~/GitHub/ModelSelection_Simulation/DataGeneration.R", echo=TRUE)
# With modelsel code (for continouos trials)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 6, N_g = 200, reg_coeff = 0.4,
balance = "bal")
# With modelsel code (for continouos trials)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 6, N_g = 200, reg_coeff = 0.4,
balance = "bal", sd = 0)
Data$SimData <- as.data.frame(Data$SimData)
# Wu asks for std.lv = T. Never been tested in MMG-sEM
# Try it
fit.con <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F, std.lv = T,
constraints = c("loadings", "thresholds"))
round(fit.con$posteriors, 1)
fit.con$param$beta_ks
fit.con$param$lambda
source("~/GitHub/OrdinalSim/Functions/MMG-SEM.R", echo=TRUE)
# Wu asks for std.lv = T. Never been tested in MMG-sEM
# Try it
fit.con <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F, std.lv = T,
constraints = c("loadings", "thresholds"))
round(fit.con$posteriors, 1)
fit.con$param$beta_ks
fit.con$param$lambda
fit.con$param$cov_eta
summary(fit.con$MM)
# Generate dummy data
set.seed(12)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 6, N_g = 50, reg_coeff = 0.4,
balance = "bal", NonInvSize = 0.2, NonInvItems = 2,
threshold = "unequal", NonInvThreshSize = 0,
NonInvType = "random", randomVarX = T, c = 2)
# With modelsel code (for continouos trials)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 6, N_g = 50, reg_coeff = 0.4,
balance = "bal", sd = 0)
Data$SimData <- as.data.frame(Data$SimData)
# Wu asks for std.lv = T. Never been tested in MMG-sEM
# Try it
fit.con <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F, std.lv = T,
constraints = c("loadings", "thresholds"))
round(fit.con$posteriors, 1)
fit.con$param$beta_ks
fit.con$param$lambda
fit.con$param$cov_eta
fit.con$model_sel$BIC
fit.con$param$psi_gks[[1,1]]
fit.con$param$psi_gks[[2,1]]
# Try Wu and Estabrook approach
Thr.Mod <- measEq.syntax(configural.model = S1,
dat = Data$SimData,
parameterization = "delta",
ordered = colnames(Data$SimData[,-c(dim(Data$SimData)[2])]),
ID.fac = "std.lv",
ID.cat = "Wu",
group = "group",
group.equal = c("thresholds"))
source("~/GitHub/OrdinalSim/DataGeneration.R", echo=TRUE)
# Generate dummy data
set.seed(12)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 6, N_g = 200, reg_coeff = 0.4,
balance = "bal", NonInvSize = 0.2, NonInvItems = 2,
threshold = "unequal", NonInvThreshSize = 0,
NonInvType = "random", randomVarX = T, c = 2)
Data$SimData <- as.data.frame(Data$SimData)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
# Try Wu and Estabrook approach
Thr.Mod <- measEq.syntax(configural.model = S1,
dat = Data$SimData,
parameterization = "delta",
ordered = colnames(Data$SimData[,-c(dim(Data$SimData)[2])]),
ID.fac = "std.lv",
ID.cat = "Wu",
group = "group",
group.equal = c("thresholds"))
fit.thr <- cfa(as.character(Thr.Mod),
data = Data$SimData,
group = "group",
ordered = T)
summary(fit.thr)
lapply(lavInspect(fit.thr, "est"), "[[", "psi")
# Wu asks for std.lv = T. Never been tested in MMG-sEM
# Try it
fit.con <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F, std.lv = T,
constraints = c("loadings", "thresholds"))
# Try with MMG-SEM
fit.cat3 <- MMGSEM(dat = Data$SimData, step1model = as.character(Thr.Mod), step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = T, NonInv = NonInv, constraints = c("loadings", "thresholds"))
fit.cat2 <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = T, std.lv = T,
NonInv = NonInv, constraints = c("loadings", "thresholds"))
fit.cat2 <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = T, std.lv = F,
NonInv = NonInv, constraints = c("loadings", "thresholds"))
round(fit.cat2$posteriors, 1)
source("~/GitHub/OrdinalSim/Functions/MMG-SEM.R", echo=TRUE)
# Try with MMG-SEM
fit.cat3 <- MMGSEM(dat = Data$SimData, step1model = as.character(Thr.Mod), step2model = S2,
group = "group", nclus = 2, seed = 1, nstarts = 20, allG = T,
est_method = "local", ordered = T, simple.step1model = S1,
NonInv = NonInv, constraints = c("loadings", "thresholds"))
source("~/GitHub/OrdinalSim/Functions/MMG-SEM.R", echo=TRUE)
source("~/GitHub/OrdinalSim/Functions/MMG-SEM.R", echo=TRUE)
# Try with MMG-SEM
fit.cat3 <- MMGSEM(dat = Data$SimData, step1model = as.character(Thr.Mod), step2model = S2,
group = "group", nclus = 2, seed = 1, nstarts = 20, allG = T,
est_method = "local", ordered = T, simple.step1model = S1,
NonInv = NonInv, constraints = c("loadings", "thresholds"))
round(fit.cat3$posteriors, 1)
fit.cat$param$beta_ks
fit.cat$param$lambda
fit.cat3$param$beta_ks
fit.cat$param$beta_ks
fit.cat3$param$cov_eta
summary(fit.cat$MM)
summary(fit.cat3$MM)
fit.cat3$param$psi_gks[[2,1]]
cor2cov(fit.cat3$param$psi_gks[[2,1]])
round(fit.cat3$posteriors, 1)
fit.cat3$param$cov_eta
cor2cov(fit.cat3$param$psi_gks[[2,1]], sds = sqrt(diag(fit.cat3$param$cov_eta[[2]])))
fit.cat3$param$cov_eta[[2]]
Data$cov_eta
cor2cov(fit.cat3$param$psi_gks[[2,1]], sds = sqrt(diag(Data$cov_eta[,,2])))
Data$cov_eta[,,2]
cor2cov(fit.cat3$param$cov_eta[[2]], sds = sqrt(diag(Data$cov_eta[,,2])))
Data$psi_g
Data$psi_g[,,2]
cor2cov(fit.cat3$param$psi_gks[[2, 1]], sds = sqrt(diag(Data$psi_g[,,2])))
fit.cat3$param$psi_gks[[2, 1]]
fit.cat3$param$psi_gks[[3, 1]]
source("~/GitHub/ModelSelection_Simulation/DataGeneration.R", echo=TRUE)
# With modelsel code (for continouos trials)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 6, N_g = 50, reg_coeff = 0.4,
balance = "bal", sd = 0)
Data$SimData <- as.data.frame(Data$SimData)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
Data$SimData <- as.data.frame(Data$SimData)
sort(Data$NonInv$load)
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings", "thresholds"), std.lv = T)
lavInspect(single.con, "est")$beta
lavInspect(single.con, "est")$psi
summary(single.con)
single.con <- sam(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings", "thresholds"), std.lv = T)
lavInspect(single.con, "est")$beta
single.con <- sam(model = model, data = single.data, ordered = F, group = "group",
group.equal = c("loadings", "thresholds"), std.lv = T, mm.list = list(c("F1", "F2", "F3", "F4")))
lavInspect(single.con, "est")$beta
list(c("F1", "F2", "F3", "F4"))
lavInspect(single.con, "est")$psi
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings", "thresholds"), std.lv = T)
lavInspect(single.con, "est")$beta
single.con <- sam(model = model, data = single.data, ordered = F, group = "group",
group.equal = c("loadings", "thresholds"), std.lv = T, mm.list = list(c("F1", "F2", "F3", "F4")))
lavInspect(single.con, "est")$beta
lavInspect(single.con, "est")$psi
cor2cov(lavInspect(single.con, "est")$psi, sds = sqrt(diag(Data$psi_g[,,1])))
Data$psi_g[,,1]
HS.model <- ' visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed   =~ x7 + x8 + x9 '
fit <- sem(HS.model, data=HolzingerSwineford1939, std.lv)
fit <- sem(HS.model, data=HolzingerSwineford1939, std.lv = T)
fit2 <- sem(HS.model, data=HolzingerSwineford1939, std.lv = F)
summary(fit)
summary(fit2)
HS.model <- ' visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed   =~ x7 + x8 + x9
visual ~ textual
'
fit <- sem(HS.model, data=HolzingerSwineford1939, std.lv = T)
fit2 <- sem(HS.model, data=HolzingerSwineford1939, std.lv = F)
summary(fit)
summary(fit2)
summary(fit2, std.all = T)
summary(fit2, std.lv = T)
summary(fit2, standardize = T)
fit2 <- sem(HS.model, data=HolzingerSwineford1939, std.lv = F)
fit <- sem(HS.model, data=HolzingerSwineford1939, std.lv = T)
fit2 <- sem(HS.model, data=HolzingerSwineford1939, std.lv = F)
summary(fit)
summary(fit2, standardize = T)
source("~/GitHub/OrdinalSim/Functions/MMG-SEM.R", echo=TRUE)
source("~/GitHub/OrdinalSim/Functions/MMG-SEM.R", echo=TRUE)
source("~/GitHub/OrdinalSim/DataGeneration.R", echo=TRUE)
# Define models for future simulations
model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
S1 <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
'
S2 <- '
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
# Generate dummy data
set.seed(12)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 6, N_g = 200, reg_coeff = 0.4,
balance = "bal", NonInvSize = 0.2, NonInvItems = 2,
threshold = "unequal", NonInvThreshSize = 0,
NonInvType = "random", randomVarX = T, c = 2)
Data$SimData <- as.data.frame(Data$SimData)
# Try Wu and Estabrook approach
Thr.Mod <- measEq.syntax(configural.model = S1,
dat = Data$SimData,
parameterization = "delta",
ordered = colnames(Data$SimData[,-c(dim(Data$SimData)[2])]),
ID.fac = "std.lv",
ID.cat = "Wu",
group = "group",
group.equal = c("thresholds"))
fit.thr <- cfa(as.character(Thr.Mod),
data = Data$SimData,
group = "group",
ordered = T)
# Try with MMG-SEM
fit.cat3 <- MMGSEM(dat = Data$SimData, step1model = as.character(Thr.Mod), step2model = S2,
group = "group", nclus = 2, seed = 1, nstarts = 20, allG = T,
est_method = "local", ordered = T, simple.step1model = S1,
NonInv = NonInv, constraints = c("loadings", "thresholds"))
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings", "thresholds"), std.lv = T)
single.con <- sam(model = model, data = single.data, ordered = F, group = "group",
group.equal = c("loadings", "thresholds"), std.lv = T, mm.list = list(c("F1", "F2", "F3", "F4")))
single.cat <- sem(model = model, data = single.data, ordered = T, group = "group", group.equal = c("loadings", "thresholds"))
partable <- partable(single.cat)
partable$full <- paste0(partable$lhs, partable$op, partable$rhs)
NoninvThresh <- partable$full[which(partable$op == "|" & partable$group == 1 & partable$lhs %in% c("x2", #, "x3",
"m2", #, "m3",
"y2", #, "y3",
"z2"))] #, "z3"))]
# Define the non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
# Try with MMG-SEM
fit.cat3 <- MMGSEM(dat = Data$SimData, step1model = as.character(Thr.Mod), step2model = S2,
group = "group", nclus = 2, seed = 1, nstarts = 20, allG = T,
est_method = "local", ordered = T, simple.step1model = S1,
NonInv = NonInv, constraints = c("loadings", "thresholds"))
fit.cat3$param$beta_ks
round(fit.cat3$posteriors, 1)
fit.cat3$param$lambda
fit.cat3$param$cov_eta
round(fit.cat3$posteriors, 1)
cor2cov(fit.cat3$param$psi_gks[[2, 1]], sds = sqrt(diag(Data$psi_g[,,2])))
Data$psi_g[,,2]
fit.cat3$param$psi_gks[[2, 1]]
source("~/GitHub/OrdinalSim/Functions/MMG-SEM.R", echo=TRUE)
# Try with MMG-SEM
fit.cat3 <- MMGSEM(dat = Data$SimData, step1model = as.character(Thr.Mod), step2model = S2,
group = "group", nclus = 2, seed = 1, nstarts = 20, allG = T,
est_method = "local", ordered = T, simple.step1model = S1,
NonInv = NonInv, constraints = c("loadings", "thresholds"))
psi
psi
psi_gks[[g, k]]
psi_gks
source("~/GitHub/OrdinalSim/Functions/MMG-SEM.R", echo=TRUE)
# Try with MMG-SEM
fit.cat3 <- MMGSEM(dat = Data$SimData, step1model = as.character(Thr.Mod), step2model = S2,
group = "group", nclus = 2, seed = 1, nstarts = 20, allG = T,
est_method = "local", ordered = T, simple.step1model = S1,
NonInv = NonInv, constraints = c("loadings", "thresholds"))
round(fit.cat3$posteriors, 1)
fit.cat3$param$beta_ks
fit.cat3$param$lambda
fit.cat3$param$cov_eta
fit.cat3$param$psi_gks[[2,1]]
cor2cov(fit.cat3$param$psi_gks[[2, 1]], sds = sqrt(diag(Data$psi_g[,,2])))
Data$psi_g[,,2]
fit.cat3$param$psi_gks[[2, 2]]
fit.cat3$param$psi_gks[[2, 1]]
fit.cat3$param$psi_gks[[3, 1]]
fit.cat3$param$beta_ks
source("~/GitHub/OrdinalSim/Functions/MMG-SEM.R", echo=TRUE)
fit.cat4 <- MMGSEM(dat = Data$SimData, step1model = as.character(Thr.Mod), step2model = S2,
group = "group", nclus = 2, seed = 1, nstarts = 20, allG = T,
est_method = "local", ordered = T, simple.step1model = S1,
NonInv = NonInv, constraints = c("loadings", "thresholds"),
end.ltv.fixed = F)
fit.cat4$param$beta_ks
fit.cat3$param$beta_ks
