color = "blue",
linetype = 2) +
theme_light() +
labs(title = "Posterior Density of Intercept")
ggplot(filter(model1tranformed, Parameter == "b_extrav", Iteration > 1000), aes(x = value))+
geom_density(fill = "orange", alpha = .5)+
geom_vline(xintercept = 0, col = "red", size = 1)+
scale_x_continuous(name = "Value", limits = c(-.2, .6))+
geom_vline(xintercept = summary(model1)$fixed[3,3], col = "blue", linetype = 2)+
geom_vline(xintercept = summary(model1)$fixed[3,4], col = "blue", linetype = 2)+
theme_light()+
labs(title = "Posterior Density of Regression Coefficient for Extraversion")
ggplot(filter(model1tranformed, Parameter == "b_sex", Iteration > 1000), aes(x = value))+
geom_density(fill = "red", alpha = .5)+
geom_vline(xintercept = 0, col = "red", size = 1)+
scale_x_continuous(name = "Value", limits = c(-.2, 1.5))+
geom_vline(xintercept = summary(model1)$fixed[2,3], col = "blue", linetype = 2)+
geom_vline(xintercept = summary(model1)$fixed[2,4], col = "blue", linetype = 2)+
theme_light()+
labs(title = "Posterior Density of Regression Coefficient for Sex")
summary(model1)$fixed
install.packages("tidybayes")
install.packages("devtools")
install.packages("fpp3")
install.packages("lavaan")
# Load required packages
library(tidyverse)
library(brms)
library(bayesplot)
# Generate simulated data
set.seed(23)
n <- 100
temperature <- runif(n, min = 0, max = 30) # Random temperatures between 0 and 30
intercept <- 10
slope <- 0.5
noise_sd <- 3
# round to whole numbers
bike_thefts <- (intercept + slope * temperature + rnorm(n, sd = noise_sd)) %>%
round(., 0)
data <- tibble(temperature = temperature, bike_thefts = bike_thefts)
View(data)
# Some initial descriptions
summary(data)
head(data)
library(ggplot2)
ggplot(data, aes(x = temperature, y = bike_thefts)) +
geom_point() +
labs(x = "Temperature", y = "Bike thefts") +
theme_minimal()
# 2) Specify and fit the model, note the sample_prior = "only"
# this makes sure we are going to look at the prior predictive samples.
fit <- brm(bike_thefts ~ temperature, data = data,
prior = priors, family = gaussian(),
sample_prior = "only", seed = 555)
# --------------------------------------------------------------------------------------------------
# Start Bayes analysis
# 1) set the priors
priors <- prior(normal(10, 5), class = "Intercept") +
prior(normal(0, 1), class = "b")
# 2) Specify and fit the model, note the sample_prior = "only"
# this makes sure we are going to look at the prior predictive samples.
fit <- brm(bike_thefts ~ temperature, data = data,
prior = priors, family = gaussian(),
sample_prior = "only", seed = 555)
library(rstantools)
# 2) Specify and fit the model, note the sample_prior = "only"
# this makes sure we are going to look at the prior predictive samples.
fit <- brm(bike_thefts ~ temperature, data = data,
prior = priors, family = gaussian(),
sample_prior = "only", seed = 555)
pp_check(fit, type = "dens_overlay", prefix = "ppd", ndraws = 100)
# 2) Specify and fit the model, note the sample_prior = "only"
# this makes sure we are going to look at the prior predictive samples.
fit <- brm(bike_thefts ~ temperature, data = data,
prior = priors, family = gaussian(),
sample_prior = "only", seed = 555)
sqrt(0.1)
load("~/GitHub/OrdinalSim/Results/Times/CatTimeIgnRow87Rep1.Rdata")
ctime.ign.cat
1102.64/60
load("~/GitHub/OrdinalSim/Results/Times/CatTimeRow87Rep1.Rdata")
ctime.cat
426.31/60
20*17400
sqrt(0.5) + 0.4
(sqrt(0.5) + 0.4) * 0.75
(sqrt(0.6) + 0.4) * 0.75
(sqrt(0.6) + 0.5) * 0.75
source("~/GitHub/OrdinalSim/DataGeneration.R", echo=TRUE)
(sqrt(0.6) + 0.4) * 0.75
(sqrt(0.6) + 0.5) * 0.8
(sqrt(0.6) + 0.5) * 0.75
(sqrt(0.5) + 0.5) * 0.8
library(lavaan)
library(semTools)
# wd
setwd("~/GitHub/OrdinalSim")
# source necessary functions
source("DataGeneration.R")
source("Functions/MMG-SEM.R")
# Define models for future simulations
model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
S1 <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
'
S2 <- '
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
# Generate dummy data
set.seed(1)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 12, N_g = 100, reg_coeff = 0.4,
balance = "unb", NonInvSize = 0.4, NonInvItems = 2, NonInvG = 0.5,
NonInvThreshSize = 0.4, NonInvGThresh = 0.5,
NonInvType = "random", c = 2)
(sqrt(0.6) + 0.5) * 0.8
(sqrt(0.6) + 0.5) * 0.75
source("~/GitHub/OrdinalSim/DataGeneration.R", echo=TRUE)
# Generate dummy data
set.seed(1)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 12, N_g = 100, reg_coeff = 0.4,
balance = "unb", NonInvSize = 0.4, NonInvItems = 2, NonInvG = 0.5,
NonInvThreshSize = 0.4, NonInvGThresh = 0.5,
NonInvType = "random", c = 2)
Data$SimData <- as.data.frame(Data$SimData)
Data$SimData_con <- as.data.frame(Data$SimData_con)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings"), std.lv = F)
single.cat <- sem(model = model, data = single.data, ordered = T, group = "group")#, "thresholds"))
cfa.cat <- cfa(model = model, data = single.data, ordered = T, group = "group", estimator = "ULS")#, "thresholds"))
lavInspect(single.con, "est")$beta
lavInspect(single.cat, "est")$beta
lavInspect(single.con, "est")$lambda
lavInspect(cfa.cat, "est")$lambda
# Define the non-invariances -----------------------------------------------------------------------
partable <- partable(single.cat)
partable$full <- paste0(partable$lhs, partable$op, partable$rhs)
NoninvThresh <- partable$full[which(partable$op == "|" & partable$group == 1 & partable$lhs %in% c("x2", "x3",
"m2", "m3",
"y2", "y3",
"z2", "z3"))]
# Define the non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
# Run MMG-SEM
# Continuous (Run normally as usual)
fit.con <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F,
group.equal = "loadings", group.partial = NonInv)
# Categorical
HolzingerSwineford1939
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global", group = "school", mm.list = c("visual", "textual", "speed"))
HS.model <- ' visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed   =~ x7 + x8 + x9 '
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global", group = "school", mm.list = c("visual", "textual", "speed"))
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global", group = "school", mm.list = c("visual", "textual", "speed"))
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global", group = "school", mm.list = list(c("visual", "textual", "speed")))
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global", group = "school", mm.list = list(c("visual", "textual", "speed")))
summary(fit.loc, fit.measures=TRUE)
summary(fit.glo, fit.measures=TRUE)
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "local", group = "school", mm.list = list(c("visual", "textual", "speed")))
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global", group = "school", mm.list = list(c("visual", "textual", "speed")))
summary(fit.loc, fit.measures=TRUE)
summary(fit.glo, fit.measures=TRUE)
HS.model <- ' visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed   =~ x7 + x8 + x9
visual ~ speed
'
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "local", group = "school", mm.list = list(c("visual", "textual", "speed")))
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global", group = "school", mm.list = list(c("visual", "textual", "speed")))
summary(fit.loc, fit.measures=TRUE)
summary(fit.glo, fit.measures=TRUE)
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "local", group = "school", mm.list = list(c("visual", "textual", "speed")) , group.equal = c("loadings", "residuals"))
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global", group = "school", mm.list = list(c("visual", "textual", "speed")), group.equal = c("loadings", "residuals"))
summary(fit.loc, fit.measures=TRUE)
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global", group = "school", mm.list = list(c("visual", "textual", "speed")), group.equal = c("loadings", "residuals"))
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "local", group = "school", mm.list = list(c("visual", "textual", "speed")) , group.equal = c("loadings", "residuals"))
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global", group = "school", mm.list = list(c("visual", "textual", "speed")), group.equal = c("loadings", "residuals"))
summary(fit.loc, fit.measures=TRUE)
summary(fit.glo, fit.measures=TRUE)
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "local", group = "school", mm.list = list(c("visual", "textual", "speed")) , group.equal = c("loadings", "residuals", "intercepts"))
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global", group = "school", mm.list = list(c("visual", "textual", "speed")), group.equal = c("loadings", "residuals", "intercepts"))
summary(fit.loc, fit.measures=TRUE)
summary(fit.glo, fit.measures=TRUE)
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "local" , mm.list = list(c("visual", "textual", "speed")))
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global", mm.list = list(c("visual", "textual", "speed")))
summary(fit.loc, fit.measures=TRUE)
summary(fit.glo, fit.measures=TRUE)
fit.sem <- sem(HS.model, data=HolzingerSwineford1939)
lavInspect(object = fit.loc, what = "est")$beta
lavInspect(object = fit.glo, what = "est")$beta
lavInspect(object = fit.sem, what = "est")$beta
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "local" , mm.list = list(c("visual", "textual", "speed")))
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global", mm.list = list(c("visual", "textual", "speed")))
lavInspect(object = fit.loc, what = "est")$beta
lavInspect(object = fit.glo, what = "est")$beta
model <- '
# measurement model
ind60 =~ x1 + x2 + x3
dem60 =~ y1 + y2 + y3 + y4
dem65 =~ y5 + y6 + y7 + y8
# regressions
dem60 ~ ind60
dem65 ~ ind60 + dem60
# residual correlations
y1 ~~ y5
y2 ~~ y4 + y6
y3 ~~ y7
y4 ~~ y8
y6 ~~ y8
'
fit3 <- sam(model = model, data = PoliticalDemocracy, mm.list = list(c("ind60", "dem60", "dem65")),
sam.method = "local")
summary(fit3)
fit4 <- sam(model = model, data = PoliticalDemocracy, mm.list = list(c("ind60", "dem60", "dem65")),
sam.method = "global")
summary(fit4)
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "local" )#, mm.list = list(c("visual", "textual", "speed")))
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global")#, mm.list = list(c("visual", "textual", "speed")))
fit.sem <- sem(HS.model, data=HolzingerSwineford1939)
lavInspect(object = fit.loc, what = "est")$beta
lavInspect(object = fit.glo, what = "est")$beta
lavInspect(object = fit.sem, what = "est")$beta
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "local", group = "school", mm.list = list(c("visual", "textual", "speed")) , group.equal = c("loadings", "residuals", "intercepts"))
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global", group = "school", mm.list = list(c("visual", "textual", "speed")), group.equal = c("loadings", "residuals", "intercepts"))
summary(fit.loc, fit.measures=TRUE)
summary(fit.glo, fit.measures=TRUE)
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "local", group = "school", mm.list = list(c("visual", "textual", "speed")) )#, group.equal = c("loadings", "residuals", "intercepts"))
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global", group = "school", mm.list = list(c("visual", "textual", "speed")))#, group.equal = c("loadings", "residuals", "intercepts"))
library(lavaan)
model <- '
# measurement model
ind60 =~ x1 + x2 + x3
dem60 =~ y1 + y2 + y3 + y4
dem65 =~ y5 + y6 + y7 + y8
# regressions
dem60 ~ ind60
dem65 ~ ind60 + dem60
# residual correlations
y1 ~~ y5
y2 ~~ y4 + y6
y3 ~~ y7
y4 ~~ y8
y6 ~~ y8
'
fit3 <- sam(model = model, data = PoliticalDemocracy, mm.list = list(c("ind60", "dem60", "dem65")),
sam.method = "local")
summary(fit3)
fit4 <- sam(model = model, data = PoliticalDemocracy, mm.list = list(c("ind60", "dem60", "dem65")),
sam.method = "global")
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "local" )#, mm.list = list(c("visual", "textual", "speed")))
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global")#, mm.list = list(c("visual", "textual", "speed")))
fit.sem <- sem(HS.model, data=HolzingerSwineford1939)
summary(fit.loc)
summary(fit.glo)
library(lavaan)
model <- '
# measurement model
ind60 =~ x1 + x2 + x3
dem60 =~ y1 + y2 + y3 + y4
dem65 =~ y5 + y6 + y7 + y8
# regressions
dem60 ~ ind60
dem65 ~ ind60 + dem60
# residual correlations
y1 ~~ y5
y2 ~~ y4 + y6
y3 ~~ y7
y4 ~~ y8
y6 ~~ y8
'
fit3 <- sam(model = model, data = PoliticalDemocracy, mm.list = list(c("ind60", "dem60", "dem65")),
sam.method = "local")
summary(fit3)
fit4 <- sam(model = model, data = PoliticalDemocracy, mm.list = list(c("ind60", "dem60", "dem65")),
sam.method = "global")
summary(fit4)
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "local" )#, mm.list = list(c("visual", "textual", "speed")))
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global")#, mm.list = list(c("visual", "textual", "speed")))
summary(fit.loc)
summary(fit.glo)
HS.model <- ' visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed   =~ x7 + x8 + x9
visual ~ speed
speed ~ textual
'
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "local" , group = "school", mm.list = list(c("visual", "textual", "speed")))#, group.equal = c("loadings", "residuals", "intercepts"))
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "local" )#, mm.list = list(c("visual", "textual", "speed")))
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global")#, mm.list = list(c("visual", "textual", "speed")))
summary(fit.loc)
summary(fit.glo)
fit.loc <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "local" , mm.list = list(c("visual", "textual", "speed")))
fit.glo <- sam(HS.model, data=HolzingerSwineford1939, sam.method = "global", mm.list = list(c("visual", "textual", "speed")))
summary(fit.loc)
summary(fit.glo)
library(lavaan)
library(semTools)
# remotes::install_github("simsem/semTools/semTools")
# wd
setwd("~/GitHub/OrdinalSim")
# source necessary functions
source("DataGeneration.R")
source("Functions/MMG-SEM.R")
# Define models for future simulations
model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
S1 <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
'
# S1 <- list('F1 =~ x1 + x2 + x3 + x4 + x5',
#            'F2 =~ z1 + z2 + z3 + z4 + z5',
#            'F3 =~ m1 + m2 + m3 + m4 + m5',
#            'F4 =~ y1 + y2 + y3 + y4 + y5')
S2 <- '
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
# Generate dummy data
set.seed(1)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 12, N_g = 100, reg_coeff = 0.4,
balance = "unb", NonInvSize = 0.4, NonInvItems = 2, NonInvG = 0.5,
NonInvThreshSize = 0.4, NonInvGThresh = 0.5,
NonInvType = "random", c = 2)
cfa.cat <- cfa(model = model, data = Data$SimData, ordered = T, group = "group", estimator = "ULS")#, "thresholds"))
cfa.cat@SampleStats@cov
# Generate dummy data
set.seed(1)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 12, N_g = 100, reg_coeff = 0.4,
balance = "unb", NonInvSize = 0.4, NonInvItems = 2, NonInvG = 0.5,
NonInvThreshSize = 0.4, NonInvGThresh = 0.5,
NonInvType = "random", c = 4)
cfa.cat <- cfa(model = model, data = Data$SimData, ordered = T, group = "group", estimator = "ULS")#, "thresholds"))
cfa.cat@SampleStats@cov
cfa.cat@vcov
lavInspect(object = cfa.cat, what = "est")$cov
lavInspect(object = cfa.cat, what = "est")[[1]]
fitted(cfa.cat)
cfa.cat <- cfa(model = model, data = Data$SimData, ordered = T, group = "group", estimator = "ULS", group.equal = ("loadings", "thresholds")))
cfa.cat <- cfa(model = model, data = Data$SimData, ordered = T, group = "group", estimator = "ULS", group.equal = ("loadings", "thresholds"))
cfa.cat <- cfa(model = model, data = Data$SimData, ordered = T, group = "group", estimator = "ULS", group.equal = c("loadings", "thresholds"))
fitted(cfa.cat)
cfa.cat <- cfa(model = model, data = Data$SimData, ordered = T, group = "group", group.equal = c("loadings", "thresholds"))
source("~/GitHub/OrdinalSim/Functions/MMG-SEM.R", echo=TRUE)
# (Non-)Invariance defined in the model syntax itself
# Re-scaling needs to be set to T to have covariances instead of correlations in the second step
fit.cat <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2,
group = "group", nclus = 2, seed = 1,
nstarts = 20, est_method = "local", ordered = T,
group.equal = c("loadings", "thresholds"),
group.partial = NonInv, estimator = "ULS")
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
# Generate dummy data
set.seed(1)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 12, N_g = 100, reg_coeff = 0.4,
balance = "unb", NonInvSize = 0.4, NonInvItems = 2, NonInvG = 0.5,
NonInvThreshSize = 0.4, NonInvGThresh = 0.5,
NonInvType = "random", c = 4)
# With modelsel code (for continouos trials)
# Data <- DataGeneration(model = model, nclus = 2, ngroups = 6, N_g = 50, reg_coeff = 0.4,
#                        balance = "bal", sd = 0)
Data$SimData <- as.data.frame(Data$SimData)
Data$SimData_con <- as.data.frame(Data$SimData_con)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings"), std.lv = F)
single.cat <- sem(model = model, data = single.data, ordered = T, group = "group")#, "thresholds"))
cfa.cat <- cfa(model = model, data = single.data, ordered = T, group = "group", estimator = "ULS")#, "thresholds"))
lavInspect(single.con, "est")$beta
lavInspect(single.cat, "est")$beta
lavInspect(single.con, "est")$lambda
lavInspect(cfa.cat, "est")$lambda
Data$lambda[[1]]
# lavInspect(single.con, "est")$psi
# lavInspect(single.cat, "est")$psi
#
# summary(single.con)
# summary(single.cat)
# Check re-scaling with single data
# single.con2 <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings"), std.lv = T)
# single.cat2 <- sem(model = model, data = single.data, ordered = T, group = "group", group.equal = c("loadings"), std.lv = T)
#
# lavInspect(single.con2, "est")$beta
# lavInspect(single.cat2, "est")$beta
#
# lavInspect(single.con2, "est")$psi
# lavInspect(single.cat2, "est")$psi
#
# lavInspect(single.con2, "est")$lambda
# lavInspect(single.cat2, "est")$lambda
#
# round(lavInspect(single.con2, "est")$psi[1,1] * lavInspect(single.con2, "est")$lambda[1,1]^2, 3) == round(lavInspect(single.con, "est")$psi[1,1], 3)
# lavInspect(single.cat2, "est")$psi[1,1] * lavInspect(single.cat2, "est")$lambda[1,1]^2
# Define the non-invariances -----------------------------------------------------------------------
partable <- partable(single.cat)
partable$full <- paste0(partable$lhs, partable$op, partable$rhs)
NoninvThresh <- partable$full[which(partable$op == "|" & partable$group == 1 & partable$lhs %in% c("x2", "x3",
"m2", "m3",
"y2", "y3",
"z2", "z3"))]
# Define the non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
# (Non-)Invariance defined in the model syntax itself
# Re-scaling needs to be set to T to have covariances instead of correlations in the second step
fit.cat <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2,
group = "group", nclus = 2, seed = 1,
nstarts = 20, est_method = "local", ordered = T,
group.equal = c("loadings", "thresholds"),
group.partial = NonInv, estimator = "ULS")
S1
lavaanify(S1)
S1 <- as.character(
semTools::measEq.syntax(configural.model = S1,
dat              = dat,
ordered          = vars,
ID.fac           = "std.lv",
ID.cat           = "Wu",
group            = group,
group.equal      = constraints,
group.partial    = noninv)
)
cfa.cat <- cfa(model = S1, data = dat, ordered = T)
constraints
cfa.cat <- cfa(model = S1, data = dat, ordered = T)
S1 <- as.character(
semTools::measEq.syntax(configural.model = S1,
dat              = dat,
parameterization = "delta",
ordered          = vars,
ID.fac           = "std.lv",
ID.cat           = "Wu",
group            = group,
group.equal      = constraints,
group.partial    = noninv)
)
cfa.cat <- cfa(model = S1, data = dat, ordered = T)
source("~/GitHub/OrdinalSim/Functions/MMG-SEM.R", echo=TRUE)
# (Non-)Invariance defined in the model syntax itself
# Re-scaling needs to be set to T to have covariances instead of correlations in the second step
fit.cat <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2,
group = "group", nclus = 2, seed = 1,
nstarts = 20, est_method = "local", ordered = T,
group.equal = c("loadings", "thresholds"),
group.partial = NonInv, estimator = "ULS")
source("~/GitHub/OrdinalSim/Functions/MMG-SEM.R", echo=TRUE)
# (Non-)Invariance defined in the model syntax itself
# Re-scaling needs to be set to T to have covariances instead of correlations in the second step
fit.cat <- MMGSEM(dat = Data$SimData, S1 = S1, S2 = S2,
group = "group", nclus = 2, seed = 1,
nstarts = 20, est_method = "local", ordered = T,
group.equal = c("loadings", "thresholds"),
group.partial = NonInv, estimator = "ULS")
cfa.cat <- cfa(model = S1, data = dat, ordered = T, group = "group")
fitted(cfa.cat)
S1 <- as.character(
semTools::measEq.syntax(configural.model = S1,
dat              = dat,
ordered          = vars,
ID.fac           = "std.lv",
ID.cat           = "Wu",
group            = group,
group.equal      = constraints,
group.partial    = noninv)
)
cfa.cat <- cfa(model = S1, data = dat, ordered = T, group = "group")
fitted(cfa.cat)
lavaanify(S1)
View(partable(cfa.fit))
View(partable(cfa.cat))
S1
