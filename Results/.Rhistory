summary(cfa(S1, ordered = "x1", do.fit = F, data = Data$SimData))
summary(cfa(S1, ordered = T, do.fit = F, data = Data$SimData))
library(lavaan)
# Set the working directory
setwd("D:/Andres/Functions")
setwd("~/GitHub/OrdinalSim")
setwd("~/GitHub/OrdinalSim/Functions")
# Source the relevant functions
source("MMG-SEM.R")
source("E_Step.R")
source("ModelSelection.R")
setwd("~/GitHub/OrdinalSim")
source("DataGeneration.R")
source("evaluation.R")
# Simulation Design
# Which factors are going to be tested? For now:
nclus            <- c(2, 4)                 # Number of clusters
ngroups          <- c(24, 48)               # Number of groups
coeff            <- c(0.2, 0.3, 0.4)        # Initial regression parameters
N_g              <- c(50, 100, 200)         # Sample size per groups
balance          <- c("bal", "unb")         # Cluster size
NonInvThreshSize <- c(0, 0.2, 0.4)          # Threshold non-invariance size
NonInvLoadSize   <- c(0.2, 0.6)             # Loading non-invariance size
c                <- c(2, 4, 5)              # Number of categories
model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
S1 <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
'
S2 <- '
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
# Get design matrix
design <- expand.grid(nclus, ngroups, coeff, N_g, balance, NonInvThreshSize, c, NonInvLoadSize, model)
colnames(design) <- c("nclus", "ngroups", "coeff", "N_g", "balance", "NonInvThreshSize", "c", "NonInvLoadSize", "model")
rownames(design) <- NULL
rm(balance, coeff, N_g, nclus, ngroups, c, NonInvLoadSize, NonInvThreshSize)
# Functions for the simulation
# First, to avoid stopping due to errors, create a function with data generation and MMGSEM
# Errors come from non positive definite cov matrices. This code allows the re-sample
genDat_analysis <- function(seed, Design, RowDesign, k, NonInv){
# browser()
tryCatch({
# Set seed per design condition (row) and replication (K)
set.seed(seed)
# Generate data
#SimData <- do.call(what = DataGeneration, args = Design[RowDesign, ])$SimData
SimData <- DataGeneration(model            = Design[RowDesign, "model"],
nclus            = Design[RowDesign, "nclus"],
ngroups          = Design[RowDesign, "ngroups"],
reg_coeff        = Design[RowDesign, "coeff"],
N_g              = Design[RowDesign, "N_g"],
balance          = Design[RowDesign, "balance"],
NonInvThreshSize = Design[RowDesign, "NonInvThreshSize"],
NonInvSize       = Design[RowDesign, "NonInvLoadSize"],
c                = Design[RowDesign, "c"])
# Get the non-invariant threshold parameters for the syntax
fake_cfa <- cfa(S1, ordered = T, do.fit = F, data = Data$SimData)
PRT <- partable(fake_cfa)
PRT$full <- paste0(PRT$lhs, PRT$op, PRT$rhs)
NoninvThresh <- PRT$full[which(PRT$op == "|" & PRT$lhs %in% c("x2", "x3",
"m2", "m3",
"y2", "y3",
"z2", "z3"))]
# Define non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
fit.con <- MMGSEM(dat = SimData$SimData, step1model = S1, step2model = S2, group = "group",
nclus = Design[RowDesign, "nclus"], seed = seed,
nstarts = 20, allG = T, est_method = "local", ordered = F,
NonInv = NonInv, constraints = c("loadings"))
fit.cat <- MMGSEM(dat = SimData$SimData, step1model = S1, step2model = S2, group = "group",
nclus = Design[RowDesign, "nclus"], seed = seed,
nstarts = 20, allG = T, est_method = "local", ordered = T,
NonInv = NonInv, constraints = c("loadings", "thresholds"))
results <- list(fit.con = fit.con, fit.cat = fit.cat)
# If everything goes right, return results
return(results)
}, error = function(e){
return(NULL)
})
}
# Main simulation function
do_sim <- function(Design, RowDesign, K){
# Create the original clustering matrix for comparison below
original <- create_original(balance = Design[RowDesign, "balance"],
ngroups = Design[RowDesign, "ngroups"],
nclus   = Design[RowDesign, "nclus"])
# Create matrix to store results
# 10 columns for: ARI and RMSEA * 2 (continuous and ordinal)
ResultsRow <- matrix(data = NA, nrow = (K), ncol = 16)
colnames(ResultsRow) <- c("ARI.con", "CC.con", "RMSE_B1.con", "RMSE_B2.con", "RMSE_B3.con", "RMSE_B4.con", "exo_mean.con", "cov_mean.con",
"ARI.cat", "CC.cat", "RMSE_B1.cat", "RMSE_B2.cat", "RMSE_B3.cat", "RMSE_B4.cat", "exo_mean.cat", "cov_mean.cat")
for(k in 1:K){
print(paste("Replication", k, "out of", K))
# browser()
# Code to re-sample in case the covariance matrix is non positive definite
attempts <- 10
for(j in 1:attempts){
# Seed will change if there is an error
ctimes <- system.time(results <- genDat_analysis(seed = (RowDesign * k * j), Design = Design, RowDesign = RowDesign, k = k))
if(!is.null(results)){
# If there was no error, break the loop and continue
break
}
}
# # Save computation times
# save(ctimes, file = paste("Times/Time", "Row", RowDesign, "Rep", k, ".Rdata", sep = ""))
# save(ctimes_ignored, file = paste("Times/TimeIgn", "Row", RowDesign, "Rep", k, ".Rdata", sep = ""))
#
# # Save results if necessary
# results <- results$Overview
# save(results, file = paste("Fit/Fit", "Row", RowDesign, "Rep", k, "-", j, ".Rdata" , sep = ""))
#
# results_ignored <- results_ignored$Overview
# save(results_ignored, file = paste("Fit/FitIgn", "Row", RowDesign, "Rep", k, "-", j, ".Rdata" , sep = ""))
# browser()
# ---------------------------------------------------------------
# Evaluate the results
Evaluated.con <- evaluation(z_gks    = results$fit.con$posteriors,
beta     = results$fit.con$param$beta_ks,
psi_gks  = results$fit.con$param$psi_gks,
original = original,
nclus    = Design[RowDesign, "nclus"],
coeff    = Design[RowDesign, "coeff"])
Evaluated.cat <- evaluation(z_gks    = results$fit.cat$posteriors,
beta     = results$fit.cat$param$beta_ks,
psi_gks  = results$fit.cat$param$psi_gks,
original = original,
nclus    = Design[RowDesign, "nclus"],
coeff    = Design[RowDesign, "coeff"])
# Store the results
ResultsRow[k, 1:8] <- unlist(Evaluated.con);
ResultsRow[k, 9:16] <- unlist(Evaluated.cat)
}
# Save the results for each row
save(ResultsRow, file = paste("Result", "Row", RowDesign,".Rdata" , sep =""))
# Return the final results
return(ResultsRow)
}
setwd("~/GitHub/OrdinalSim")
setwd("~/GitHub/OrdinalSim/Results")
# Create final results matrix
# Everything is multiplied by 2 because we run the model twice (including and not including Non-Inv)
K <- 1 # Number of replications per condition
Results_final <- as.data.frame(matrix(data = NA, nrow = nrow(design)*K, ncol = 16))
Results_final$Replication <- rep(x = 1:K, times = nrow(design))
Results_final$Condition <- rep(x = 1:nrow(design), each = K)
system.time(for(i in 1:1){
cat("\n", "Condition", i, "out of", nrow(design), "\n")
Results <- do_sim(Design = design, RowDesign = i, K = K)
Results_final[(K*(i-1)+1):(i*K), 1:16] <- Results
})
# Main simulation function
do_sim <- function(Design, RowDesign, K){
# Create the original clustering matrix for comparison below
original <- create_original(balance = Design[RowDesign, "balance"],
ngroups = Design[RowDesign, "ngroups"],
nclus   = Design[RowDesign, "nclus"])
# Create matrix to store results
# 10 columns for: ARI and RMSEA * 2 (continuous and ordinal)
ResultsRow <- matrix(data = NA, nrow = (K), ncol = 16)
colnames(ResultsRow) <- c("ARI.con", "CC.con", "RMSE_B1.con", "RMSE_B2.con", "RMSE_B3.con", "RMSE_B4.con", "exo_mean.con", "cov_mean.con",
"ARI.cat", "CC.cat", "RMSE_B1.cat", "RMSE_B2.cat", "RMSE_B3.cat", "RMSE_B4.cat", "exo_mean.cat", "cov_mean.cat")
for(k in 1:K){
print(paste("Replication", k, "out of", K))
browser()
# Code to re-sample in case the covariance matrix is non positive definite
attempts <- 10
for(j in 1:attempts){
# Seed will change if there is an error
ctimes <- system.time(results <- genDat_analysis(seed = (RowDesign * k * j), Design = Design, RowDesign = RowDesign, k = k))
if(!is.null(results)){
# If there was no error, break the loop and continue
break
}
}
# # Save computation times
# save(ctimes, file = paste("Times/Time", "Row", RowDesign, "Rep", k, ".Rdata", sep = ""))
# save(ctimes_ignored, file = paste("Times/TimeIgn", "Row", RowDesign, "Rep", k, ".Rdata", sep = ""))
#
# # Save results if necessary
# results <- results$Overview
# save(results, file = paste("Fit/Fit", "Row", RowDesign, "Rep", k, "-", j, ".Rdata" , sep = ""))
#
# results_ignored <- results_ignored$Overview
# save(results_ignored, file = paste("Fit/FitIgn", "Row", RowDesign, "Rep", k, "-", j, ".Rdata" , sep = ""))
# browser()
# ---------------------------------------------------------------
# Evaluate the results
Evaluated.con <- evaluation(z_gks    = results$fit.con$posteriors,
beta     = results$fit.con$param$beta_ks,
psi_gks  = results$fit.con$param$psi_gks,
original = original,
nclus    = Design[RowDesign, "nclus"],
coeff    = Design[RowDesign, "coeff"])
Evaluated.cat <- evaluation(z_gks    = results$fit.cat$posteriors,
beta     = results$fit.cat$param$beta_ks,
psi_gks  = results$fit.cat$param$psi_gks,
original = original,
nclus    = Design[RowDesign, "nclus"],
coeff    = Design[RowDesign, "coeff"])
# Store the results
ResultsRow[k, 1:8] <- unlist(Evaluated.con);
ResultsRow[k, 9:16] <- unlist(Evaluated.cat)
}
# Save the results for each row
save(ResultsRow, file = paste("Result", "Row", RowDesign,".Rdata" , sep =""))
# Return the final results
return(ResultsRow)
}
system.time(for(i in 1:1){
cat("\n", "Condition", i, "out of", nrow(design), "\n")
Results <- do_sim(Design = design, RowDesign = i, K = K)
Results_final[(K*(i-1)+1):(i*K), 1:16] <- Results
})
Design[1, ]
# Main simulation function
do_sim <- function(Design, RowDesign, K){
# Create the original clustering matrix for comparison below
original <- create_original(balance = Design[RowDesign, "balance"],
ngroups = Design[RowDesign, "ngroups"],
nclus   = Design[RowDesign, "nclus"])
# Create matrix to store results
# 10 columns for: ARI and RMSEA * 2 (continuous and ordinal)
ResultsRow <- matrix(data = NA, nrow = (K), ncol = 16)
colnames(ResultsRow) <- c("ARI.con", "CC.con", "RMSE_B1.con", "RMSE_B2.con", "RMSE_B3.con", "RMSE_B4.con", "exo_mean.con", "cov_mean.con",
"ARI.cat", "CC.cat", "RMSE_B1.cat", "RMSE_B2.cat", "RMSE_B3.cat", "RMSE_B4.cat", "exo_mean.cat", "cov_mean.cat")
for(k in 1:K){
print(paste("Replication", k, "out of", K))
# browser()
# Code to re-sample in case the covariance matrix is non positive definite
attempts <- 10
for(j in 1:attempts){
# Seed will change if there is an error
ctimes <- system.time(results <- genDat_analysis(seed = (RowDesign * k * j), Design = Design, RowDesign = RowDesign, k = k))
if(!is.null(results)){
# If there was no error, break the loop and continue
break
}
}
# # Save computation times
# save(ctimes, file = paste("Times/Time", "Row", RowDesign, "Rep", k, ".Rdata", sep = ""))
# save(ctimes_ignored, file = paste("Times/TimeIgn", "Row", RowDesign, "Rep", k, ".Rdata", sep = ""))
#
# # Save results if necessary
# results <- results$Overview
# save(results, file = paste("Fit/Fit", "Row", RowDesign, "Rep", k, "-", j, ".Rdata" , sep = ""))
#
# results_ignored <- results_ignored$Overview
# save(results_ignored, file = paste("Fit/FitIgn", "Row", RowDesign, "Rep", k, "-", j, ".Rdata" , sep = ""))
# browser()
# ---------------------------------------------------------------
# Evaluate the results
Evaluated.con <- evaluation(z_gks    = results$fit.con$posteriors,
beta     = results$fit.con$param$beta_ks,
psi_gks  = results$fit.con$param$psi_gks,
original = original,
nclus    = Design[RowDesign, "nclus"],
coeff    = Design[RowDesign, "coeff"])
Evaluated.cat <- evaluation(z_gks    = results$fit.cat$posteriors,
beta     = results$fit.cat$param$beta_ks,
psi_gks  = results$fit.cat$param$psi_gks,
original = original,
nclus    = Design[RowDesign, "nclus"],
coeff    = Design[RowDesign, "coeff"])
# Store the results
ResultsRow[k, 1:8] <- unlist(Evaluated.con);
ResultsRow[k, 9:16] <- unlist(Evaluated.cat)
}
# Save the results for each row
save(ResultsRow, file = paste("Result", "Row", RowDesign,".Rdata" , sep =""))
# Return the final results
return(ResultsRow)
}
# Functions for the simulation
# First, to avoid stopping due to errors, create a function with data generation and MMGSEM
# Errors come from non positive definite cov matrices. This code allows the re-sample
genDat_analysis <- function(seed, Design, RowDesign, k, NonInv){
browser()
tryCatch({
# Set seed per design condition (row) and replication (K)
set.seed(seed)
# Generate data
#SimData <- do.call(what = DataGeneration, args = Design[RowDesign, ])$SimData
SimData <- DataGeneration(model            = Design[RowDesign, "model"],
nclus            = Design[RowDesign, "nclus"],
ngroups          = Design[RowDesign, "ngroups"],
reg_coeff        = Design[RowDesign, "coeff"],
N_g              = Design[RowDesign, "N_g"],
balance          = Design[RowDesign, "balance"],
NonInvThreshSize = Design[RowDesign, "NonInvThreshSize"],
NonInvSize       = Design[RowDesign, "NonInvLoadSize"],
c                = Design[RowDesign, "c"])
# Get the non-invariant threshold parameters for the syntax
fake_cfa <- cfa(S1, ordered = T, do.fit = F, data = Data$SimData)
PRT <- partable(fake_cfa)
PRT$full <- paste0(PRT$lhs, PRT$op, PRT$rhs)
NoninvThresh <- PRT$full[which(PRT$op == "|" & PRT$lhs %in% c("x2", "x3",
"m2", "m3",
"y2", "y3",
"z2", "z3"))]
# Define non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
fit.con <- MMGSEM(dat = SimData$SimData, step1model = S1, step2model = S2, group = "group",
nclus = Design[RowDesign, "nclus"], seed = seed,
nstarts = 20, allG = T, est_method = "local", ordered = F,
NonInv = NonInv, constraints = c("loadings"))
fit.cat <- MMGSEM(dat = SimData$SimData, step1model = S1, step2model = S2, group = "group",
nclus = Design[RowDesign, "nclus"], seed = seed,
nstarts = 20, allG = T, est_method = "local", ordered = T,
NonInv = NonInv, constraints = c("loadings", "thresholds"))
results <- list(fit.con = fit.con, fit.cat = fit.cat)
# If everything goes right, return results
return(results)
}, error = function(e){
return(NULL)
})
}
system.time(for(i in 1:1){
cat("\n", "Condition", i, "out of", nrow(design), "\n")
Results <- do_sim(Design = design, RowDesign = i, K = K)
Results_final[(K*(i-1)+1):(i*K), 1:16] <- Results
})
# Functions for the simulation
# First, to avoid stopping due to errors, create a function with data generation and MMGSEM
# Errors come from non positive definite cov matrices. This code allows the re-sample
genDat_analysis <- function(seed, Design, RowDesign, k, NonInv){
# browser()
tryCatch({
# Set seed per design condition (row) and replication (K)
set.seed(seed)
# Generate data
#SimData <- do.call(what = DataGeneration, args = Design[RowDesign, ])$SimData
SimData <- DataGeneration(model            = Design[RowDesign, "model"],
nclus            = Design[RowDesign, "nclus"],
ngroups          = Design[RowDesign, "ngroups"],
reg_coeff        = Design[RowDesign, "coeff"],
N_g              = Design[RowDesign, "N_g"],
balance          = Design[RowDesign, "balance"],
NonInvThreshSize = Design[RowDesign, "NonInvThreshSize"],
NonInvSize       = Design[RowDesign, "NonInvLoadSize"],
c                = Design[RowDesign, "c"])
# Get the non-invariant threshold parameters for the syntax
fake_cfa <- cfa(S1, ordered = T, do.fit = F, data = SimData$SimData)
PRT <- partable(fake_cfa)
PRT$full <- paste0(PRT$lhs, PRT$op, PRT$rhs)
NoninvThresh <- PRT$full[which(PRT$op == "|" & PRT$lhs %in% c("x2", "x3",
"m2", "m3",
"y2", "y3",
"z2", "z3"))]
# Define non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
fit.con <- MMGSEM(dat = SimData$SimData, step1model = S1, step2model = S2, group = "group",
nclus = Design[RowDesign, "nclus"], seed = seed,
nstarts = 20, allG = T, est_method = "local", ordered = F,
NonInv = NonInv, constraints = c("loadings"))
fit.cat <- MMGSEM(dat = SimData$SimData, step1model = S1, step2model = S2, group = "group",
nclus = Design[RowDesign, "nclus"], seed = seed,
nstarts = 20, allG = T, est_method = "local", ordered = T,
NonInv = NonInv, constraints = c("loadings", "thresholds"))
results <- list(fit.con = fit.con, fit.cat = fit.cat)
# If everything goes right, return results
return(results)
}, error = function(e){
return(NULL)
})
}
system.time(for(i in 1:1){
cat("\n", "Condition", i, "out of", nrow(design), "\n")
Results <- do_sim(Design = design, RowDesign = i, K = K)
Results_final[(K*(i-1)+1):(i*K), 1:16] <- Results
})
274/60
View(Results)
design[1, ]
# Generate dummy data
set.seed(12)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 12, N_g = 50, reg_coeff = 0.2,
balance = "bal", NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5,
NonInvThreshSize = 0.2, NonInvGThresh = 0.5,
NonInvType = "random", randomVarX = T, c = 2)
# With modelsel code (for continouos trials)
# Data <- DataGeneration(model = model, nclus = 2, ngroups = 6, N_g = 50, reg_coeff = 0.4,
#                        balance = "bal", sd = 0)
Data$SimData <- as.data.frame(Data$SimData)
sort(Data$NonInv$load)
sort(Data$NonInv$thresh)
# Normal SEM
single.data <- Data$SimData[Data$SimData$group %in% c(1), ]
single.con <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings"), std.lv = F)
# single.con <- sam(model = model, data = single.data, ordered = F, group = "group",
#                   group.equal = c("loadings", "thresholds"), std.lv = T, mm.list = list(c("F1", "F2", "F3", "F4")))
single.cat <- sem(model = model, data = single.data, ordered = T, group = "group")#, "thresholds"))
lavInspect(single.con, "est")$beta
lavInspect(single.cat, "est")$beta
# lavInspect(single.con, "est")$psi
# lavInspect(single.cat, "est")$psi
#
# summary(single.con)
# summary(single.cat)
# Check re-scaling with single data
# single.con2 <- sem(model = model, data = single.data, ordered = F, group = "group", group.equal = c("loadings"), std.lv = T)
# single.cat2 <- sem(model = model, data = single.data, ordered = T, group = "group", group.equal = c("loadings"), std.lv = T)
#
# lavInspect(single.con2, "est")$beta
# lavInspect(single.cat2, "est")$beta
#
# lavInspect(single.con2, "est")$psi
# lavInspect(single.cat2, "est")$psi
#
# lavInspect(single.con2, "est")$lambda
# lavInspect(single.cat2, "est")$lambda
#
# round(lavInspect(single.con2, "est")$psi[1,1] * lavInspect(single.con2, "est")$lambda[1,1]^2, 3) == round(lavInspect(single.con, "est")$psi[1,1], 3)
# lavInspect(single.cat2, "est")$psi[1,1] * lavInspect(single.cat2, "est")$lambda[1,1]^2
# Define the non-invariances -----------------------------------------------------------------------
partable <- partable(single.cat)
partable$full <- paste0(partable$lhs, partable$op, partable$rhs)
NoninvThresh <- partable$full[which(partable$op == "|" & partable$group == 1 & partable$lhs %in% c("x2", "x3",
"m2", "m3",
"y2", "y3",
"z2", "z3"))]
# Define the non-invariances
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3",
NoninvThresh)
# Run MMG-SEM
# Continuous (Run normally as usual)
fit.con <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2, group = "group", nclus = 2, seed = 1,
nstarts = 20, allG = T, est_method = "local", ordered = F, constraints = c("loadings"),
NonInv = NonInv)
# Categorical
# Use Wu and Estabrook for the invariance setting
# Thr.Mod <- measEq.syntax(configural.model = S1,
#                          dat = Data$SimData,
#                          parameterization = "delta",
#                          ordered = colnames(Data$SimData[,-c(dim(Data$SimData)[2])]),
#                          ID.fac = "std.lv",
#                          ID.cat = "Wu",
#                          group = "group",
#                          group.equal = c("thresholds", "loadings"), group.partial = NonInv)
# (Non-)Invariance defined in the model syntax itself
# Re-scaling needs to be set to T to have covariances instead of correlations in the second step
fit.cat <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2,
group = "group", nclus = 2, seed = 1, nstarts = 20, allG = T,
est_method = "local", ordered = T, constraints = c("loadings", "thresholds"))#, NonInv = NonInv)
# Check results
round(fit.con$posteriors, 1)
round(fit.cat$posteriors, 1)
fit.con$param$beta_ks
fit.cat$param$beta_ks
fit.con$param$lambda[[1]]
fit.cat$param$lambda[[1]]
lapply(lavInspect(fit.cat$MM, what = "est"), "[[", "tau")
# Check results
round(fit.con$posteriors, 1)
round(fit.cat$posteriors, 1)
fit.con$param$beta_ks
fit.cat$param$beta_ks
# (Non-)Invariance defined in the model syntax itself
# Re-scaling needs to be set to T to have covariances instead of correlations in the second step
fit.cat <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2,
group = "group", nclus = 2, seed = 1, nstarts = 20, allG = T,
est_method = "local", ordered = T, constraints = c("loadings", "thresholds"), NonInv = NonInv)
# Check results
round(fit.con$posteriors, 1)
round(fit.cat$posteriors, 1)
fit.con$param$beta_ks
fit.cat$param$beta_ks
source("~/GitHub/OrdinalSim/Functions/MMG-SEM.R", echo=TRUE)
# (Non-)Invariance defined in the model syntax itself
# Re-scaling needs to be set to T to have covariances instead of correlations in the second step
fit.cat <- MMGSEM(dat = Data$SimData, step1model = S1, step2model = S2,
group = "group", nclus = 2, seed = 1, nstarts = 20, allG = T,
est_method = "local", ordered = T, constraints = c("loadings", "thresholds"), NonInv = NonInv)
source("~/GitHub/OrdinalSim/Functions/MMG-SEM.R", echo=TRUE)
cat <- cfa(model = S1, data = Data$SimData, ordered = T, group = "group", group.equal = "loadings")
summary(cat)
cat
cat@Options
cat <- cfa(model = S1, data = Data$SimData, ordered = T, group = "group", group.equal = "loadings", std.lv = T)
cat@Options$parameterization
sqrt(0.8)
0.8^2
